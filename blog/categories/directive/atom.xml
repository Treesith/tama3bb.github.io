<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: directive | AngularJS Ninja]]></title>
  <link href="http://angularjsninja.com/blog/categories/directive/atom.xml" rel="self"/>
  <link href="http://angularjsninja.com/"/>
  <updated>2014-01-22T13:23:06+09:00</updated>
  <id>http://angularjsninja.com/</id>
  <author>
    <name><![CDATA[Akihito Tamagawa]]></name>
    <email><![CDATA[tama3bb@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AngularJS Directive なんてこわくない（その４）]]></title>
    <link href="http://angularjsninja.com/blog/2013/11/29/angularjs-custom-directives/"/>
    <updated>2013-11-29T15:33:32+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/11/29/angularjs-custom-directives</id>
    <content type="html"><![CDATA[<hr />

<h2>controller, require</h2>

<p><a href="/blog/2013/11/20/angularjs-custom-directives/">その１</a>、<a href="/blog/2013/11/22/angularjs-custom-directives/">その２</a>、<a href="/blog/2013/11/27/angularjs-custom-directives/">その３</a>に引き続き、今回もカスタム directive について。</p>

<p>今回のサンプルコードは、UI Bootstrap の <a href="https://github.com/angular-ui/bootstrap/tree/master/src/tabs">Tabs</a> からの一部抜粋で、<code>controller</code> <code>require</code>オプションについて見ていく。</p>

<p>``` javascript tabs.js
angular.module(&lsquo;ui.bootstrap.tabs&rsquo;, [])
.controller(&lsquo;TabsetController&rsquo;, [&lsquo;$scope&rsquo;, function TabsetCtrl($scope) {
  var ctrl = this,</p>

<pre><code>  tabs = ctrl.tabs = $scope.tabs = [];
</code></pre>

<p>  ctrl.select = function(tab) {</p>

<pre><code>angular.forEach(tabs, function(tab) {
  tab.active = false;
});
tab.active = true;
</code></pre>

<p>  };
  // &hellip;
}])</p>

<p>.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>restrict: 'EA',
transclude: true,
replace: true,
require: '^tabset',
scope: {},
controller: 'TabsetController',
templateUrl: 'template/tabs/tabset.html',
compile: function(elm, attrs, transclude) {
  return function(scope, element, attrs, tabsetCtrl) {
    // ...
  };
}
</code></pre>

<p>  };
})</p>

<p>.directive(&lsquo;tab&rsquo;, [&lsquo;$parse&rsquo;, function($parse) {
  return {</p>

<pre><code>require: '^tabset',
restrict: 'EA',
replace: true,
templateUrl: 'template/tabs/tab.html',
transclude: true,
scope: {
  heading: '@',
  onSelect: '&amp;select',
  onDeselect: '&amp;deselect'
},
controller: function() {},
compile: function(elm, attrs, transclude) {
  return function postLink(scope, elm, attrs, tabsetCtrl) {
    // ...
    scope.$watch('active', function(active) {
      setActive(scope.$parent, active);
      if (active) {
        tabsetCtrl.select(scope);
        scope.onSelect();
      } else {
        scope.onDeselect();
      }
    });
    // ...
    scope.select = function() {
      if (!scope.disabled ) {
        scope.active = true;
      }
    };
    tabsetCtrl.addTab(scope);
    scope.$on('$destroy', function() {
      tabsetCtrl.removeTab(scope);
    });
    // ...
  };
}
</code></pre>

<p>  };
}])
```</p>

<!-- more -->


<h2>controller</h2>

<p>directive にも<code>ng-controller</code>で利用するときに定義するのと同じような<code>controller</code>を記述でき、<code>$scope</code>や<code>$http</code>などをインジェクト（DI）することもできる。directive の場合でも、<code>controller</code>では DOM 操作するコードは記述しないようにし、<code>compile</code>または <code>link</code>のほうに記述する。</p>

<p>なお、directive の<code>controller</code>には、モジュールで定義した<code>controller</code>の名前を記述することができる。</p>

<p>``` javascript
.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>...,
controller: 'TabsetController',
...
</code></pre>

<p>  };
})
```</p>

<p>注意すべき点としては、再利用されるコンポーネントとして directive を作成する場合、<code>controller</code>に付ける名前が重複されにくい名前にしておくこと。</p>

<p><code>controller</code>に名前を付けずに、直接 function を記述することもできる。</p>

<p>``` javascript
.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>...,
controller: ['$scope', function($scope) {
  // ...
}],
...
</code></pre>

<p>  };
})
```</p>

<p><code>$scope</code>だけでなく<code>$http</code>や<code>$timeout</code>などをインジェクト（DI）できる。また、directive の<code>controller</code>では<code>$element</code> <code>$attrs</code> <code>$transclude</code>の service をインジェクトできるようになっている。</p>

<p><code>link</code>でも<code>controller</code>でも、どちらでも同じような処理を記述することができそうに思う。違う点は、DI を利用できるか否かと、処理のタイミング（<code>controller</code>が先で、<code>link</code>が後）。使い分けのヒントとしては、子要素など別の directive から呼び出すのであれば<code>controller</code>として API を公開する感じで実装し、そうでなければ<code>link</code>で実装するという感じで。</p>

<h2>require</h2>

<p>ネストされた directive から親の directive の<code>controller</code>で定義された API を呼び出すには<code>require</code>が必要となる。</p>

<p>上のコード例では、<code>require: '^tabset'</code>の記述があり、これによって<code>tabset</code> directive の<code>controller</code>である<code>tabsetCtrl</code>を参照して API を利用できるようになる。</p>

<p>``` javascript
compile: function(elm, attrs, transclude) {
  return function postLink(scope, elm, attrs, tabsetCtrl) {</p>

<pre><code>tabsetCtrl.select(scope);
tabsetCtrl.addTab(scope);
tabsetCtrl.removeTab(scope);
</code></pre>

<p>  };
}
```</p>

<p>なお、<code>^</code>を付けない場合、親階層ではなく directive を指定した要素の<code>controller</code>を探すこととなる。このケースでよく使うのは<code>require: 'ngModel'</code>で、directive と同じ要素に<code>ng-model="..."</code>の記述があることを前提として実装できることになる。</p>

<p>同じ要素に<code>ng-model</code>属性の記述が無い場合、こんなエラーになる。</p>

<p><code>
Error: [$compile:ctreq] Controller 'ngModel', required by directive 'input', can't be found!
</code></p>

<p>このエラーを発生させる必要が無いなら、<code>require: '?ngModel'</code>のように<code>?</code>を付けて記述する。</p>

<h2>これでもうカスタム directive を書ける</h2>

<p>この４回目で<code>controller</code>と<code>require</code>を使って、複数の directive でコンポーネントを構成することについての理解も進んだので、どんどん directive を活用していこう！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Directive なんてこわくない（その３）]]></title>
    <link href="http://angularjsninja.com/blog/2013/11/27/angularjs-custom-directives/"/>
    <updated>2013-11-27T12:02:43+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/11/27/angularjs-custom-directives</id>
    <content type="html"><![CDATA[<hr />

<h2>replace, transclude, scope</h2>

<p><a href="/blog/2013/11/20/angularjs-custom-directives/">前々回</a>、<a href="/blog/2013/11/22/angularjs-custom-directives/">前回</a>に引き続き、今回もカスタム directive について。</p>

<p>今回のサンプルコードは、UI Bootstrap の <a href="https://github.com/angular-ui/bootstrap/tree/master/src/alert">Alert</a> からで、<code>replace</code> <code>transclude</code> <code>scope</code>オプションについて見ていく。</p>

<p>``` javascript alert.js
angular.module(&ldquo;ui.bootstrap.alert&rdquo;, []).directive(&lsquo;alert&rsquo;, function() {
  return {</p>

<pre><code>restrict:'EA',
templateUrl:'template/alert/alert.html',
transclude:true,
replace:true,
scope: {
  type: '=',
  close: '&amp;'
},
link: function(scope, iElement, iAttrs) {
  scope.closeable = "close" in iAttrs;
}
</code></pre>

<p>  };
});
<code>
</code> html template/alert/alert.html</p>

<div class="alert" ng-class="type && 'alert-' + type">
    <button ng-show="closeable" type="button" class="close" ng-click="close()">&times;</button>
    <div ng-transclude></div>
</div>


<p><code>

</code> html
<alert ng-repeat="alert in alerts" type="alert.type" close="closeAlert($index)">
  {{alert.msg}}
</alert>
```
</p>

<!-- more -->


<h2>replace</h2>

<p><code>template</code>または<code>templateUrl</code>で指定された HTML のフラグメントは、デフォルトでは directive を指定した要素の内側に append される。</p>

<p>``` html
<alert ...>
  <div class='alert' ...></p>

<pre><code>...
</code></pre>

<p>  </div>
</alert>
```</p>

<p>このコード例のように、directive を要素として指定できるよう<code>restrict</code>に<code>'E'</code>を含めるときには、HTML として不適当な要素名が記述されることになるため、<code>replace: true</code>を指定する前提で directive を設計しよう。</p>

<p><code>replace: true</code> を指定することによって、directive を指定した要素自体を置き換えることができるので、directive がコンパイルされた結果は以下のようなコードとなる。</p>

<p>
``` html</p>

<div ng-class="type && 'alert-' + type" class="alert ng-scope" close="closeAlert($index)" type="alert.type" ng-repeat="alert in alerts">
    <button ng-click="close()" class="close" type="button" ng-show="closeable">×</button>
    <div ng-transclude=""><span class="ng-scope ng-binding">Another alert!</span></div>
</div>


<p>```
</p>

<p><code>replace: true</code> の場合、 directive を指定した要素にある属性は、テンプレート側のルート要素にコピーされる。なので、<code>ng-repeat="alert in alerts"</code>や<code>type="alert.type"</code>、<code>close="closeAlert($index)"</code>も有効となる。</p>

<p>両方に class 属性があるケースでは、両方の class 属性値をいい感じにマージしてくれる。</p>

<h2>transclude</h2>

<p><code>transclude</code>には、<code>true</code>または<code>'element'</code>を指定でき、directive とした要素の内容を、テンプレートの一部として利用できる。</p>

<p><code>javascript
transclude: true // directive 要素の内容（内側）をテンプレートで利用
transclude: 'element' // directive 要素ごとテンプレートで利用
</code></p>

<p>テンプレート側に ng-transclude を指定した要素の内側に append できる。上記サンプルコードの例では、<code>{{alert.msg}}</code>が<code>&lt;div ng-transclude&gt;</code>の内側に append される。</p>

<p>上記コード例では、<code>alert</code>directive の内側部分<code>{{alert.msg}}</code>が、<code>ng-transclude</code>に append されていることがわかる（<code>alert.msg: 'Another alert!'</code>という前提）。</p>

<h2>scope</h2>

<p>scope には、以下の３種類の指定方法がある。</p>

<p><code>javascript
scope: false // directive が利用される場所での scope を利用（デフォルト）
scope: true // directive が利用される場所での scope を継承する、新たな scope を生成
scope: {...} // directive が利用される場所での scope を継承しない、独立した新たな scope を生成
</code></p>

<p><code>scope: true</code>が指定されている代表的な directive は<code>ng-controller</code>で、ご存知のとおり<code>ng-controller</code>を利用すると scope を継承する新たな scope が生成される。これにより、親の scope にあるデータや function を利用したり、オーバーライドしたりできるようになる。</p>

<p>一方で、コンポーネントとして再利用可能な directive を設計するには、directive を利用する場所での scope による影響を受けない分離・独立した scope を生成したい。</p>

<p><code>javascript
scope: {
  name: '@', // interpolate（値、string）
  info: '=', // data bind
  cancel: '&amp;' // expression（function）
}
</code>
このように、<code>scope</code>にオブジェクトを記述することで、この directive が利用されるたびに<code>name</code> <code>info</code> <code>cancel</code>のみ存在する新たな scope が生成される。</p>

<p>なお、directive を利用する側と、テンプレート側とで異なる名前を使いたいときは、以下のように記述することができる。
<code>javascript
scope: {
  customerInfo: '=info'
}
</code>
こうすることで、テンプレート内では<code>customerInfo</code>を、directive を利用する要素での属性名には<code>info</code>を利用できるようになる。</p>

<h2>４回目へ向けて</h2>

<p>この３回目で、再利用のための directive を記述する方法が理解できた。もう Directive なんてこわくない！</p>

<p>なんだけど、<a href="/blog/2013/11/29/angularjs-custom-directives/">４回目</a>でも引き続き、<code>controller</code> <code>require</code>といった directive のプロパティを扱う。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Directive なんてこわくない（その２）]]></title>
    <link href="http://angularjsninja.com/blog/2013/11/22/angularjs-custom-directives/"/>
    <updated>2013-11-22T13:37:02+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/11/22/angularjs-custom-directives</id>
    <content type="html"><![CDATA[<hr />

<h2>compile と link</h2>

<p><a href="/blog/2013/11/20/angularjs-custom-directives/">前回</a>に引き続き、今回もカスタム directive について。</p>

<p>２回目の今回は、<code>compile</code>と<code>link</code>の使い分けについて。</p>

<h2>compile のサンプルコード</h2>

<p>まずは<code>compile</code>を利用するサンプルコードを、『<a href="http://www.amazon.co.jp/dp/B00EQ67J30">Mastering Web Application Development with AngularJS</a>』から抜粋して見ていく。</p>

<p>このコードでは、Bootstrap の理由を前提として、以下に示すように Bootstrap でのボタンデザインに必要な CSS class の値を追加する処理を、<code>compile</code>で実装している。</p>

<p>``` javascript
myModule.directive(&lsquo;button&rsquo;, function() {
  return {</p>

<pre><code>restrict: 'E',
compile: function(element, attrs) {
  element.addClass('btn');
  if (attrs.type === 'submit') {
    element.addClass('btn-primary');
  }
  if (attrs.size) {
    element.addClass('btn-' + attrs.size);
  }
}
</code></pre>

<p>  };
});
```</p>

<ul>
<li><code>&lt;button&gt;</code>の class 属性に<code>btn</code>を追加</li>
<li><code>&lt;button type="submit"&gt;</code>のように <code>type="submit"</code>がある場合には、class 属性に<code>btn-primary</code>を追加</li>
<li><code>&lt;button size="..."&gt;</code>のように size 属性がある場合には、<code>btn-large</code>など、<code>btn-</code> と size 属性で指定した文字列を組み合わせた文字列を class 属性に追加</li>
</ul>


<p>コードからわかるように、compile オプションの function 第１引数にある<code>element</code>は、jQuery（jqLite）オブジェクトになっているので、直接 jQuery の API を利用できる。つまり<code>$(element)</code>や、<code>$(button)</code>などとしてやる必要はない。</p>

<p>第２引数の<code>attrs</code>では<code>attrs.size</code>のようにドット区切りで属性値にアクセスできるので、HTML テンプレート側の値を簡単に参照することができる。</p>

<!-- more -->


<h2>compile の流れ</h2>

<p>AngularJS が HTML テンプレートをコンパイルするために、標準の directives とカスタム定義した directives のすべてを、DOM の要素・属性・コメント・CSS class から探し出す。各 directive の<code>compile</code>function を呼び出し、<code>compile</code>function から返される<code>link</code>function を後で呼び出すために集めていく流れとなる。</p>

<p>なお、directives をコンパイルしていく処理の順序は<code>priority</code>の大きい順となるが、これについてはまた別の機会に先送り。</p>

<p>重要なポイントとしては、<code>compile</code>の処理は scope ができる前の処理であり、<code>compile</code>function では scope を利用できない。</p>

<p>すべてのコンパイル処理が終わった後、生成した scope を付けて<code>link</code>function を呼び出す流れとなり、この時点で<code>link</code>function の scope を利用した DOM との間での双方向バインドが効くことになる。</p>

<h2>compile と link の使い分け</h2>

<p><code>ng-repeat</code>の内側にある directive というケースなど、同じ directive が繰り返し使われることになるような場合では、<code>compile</code>の function は<code>ng-repeat</code>の繰り返しに関係なく一度だけ呼び出されるのに対し、<code>link</code>の function はイテレーションのたびに呼び出されることになる。</p>

<p>これは、scope のデータや双方向バインドに依存ぜずに処理できる上記のサンプルコードのようなケースであれば、<code>compile</code>を使うことで同じ処理を繰り返す無駄を省くように最適化できることになる。</p>

<p><code>compile</code>と<code>link</code>の両方を指定した場合には<code>link</code>が無視される仕様になっているため、両方を利用した実装をしたい場合には<code>compile</code>function から<code>link</code>function を return するよう実装することになる。</p>

<h2>link のサンプルコード</h2>

<p>ここから、最もよく利用することになる<code>link</code>の書き方について見ていく。</p>

<p>``` javascript
myModule.directive(&lsquo;myDirective&rsquo;, function () {
  return {</p>

<pre><code>link: function (scope, element) {
  scope.$watch('xxxVar', function () {
    // ...
  });
  scope.$on('xxxEvent', function () {
    // ...
  });
}
</code></pre>

<p>  };
});
<code>``
このように、</code>link<code>では、</code>scope`にあるモデルの変更を検知して処理することや、イベントに応じた処理を記述して、DOM や controller とのやり取りを記述していく。</p>

<h2>いろいろある link の書き方</h2>

<p>Directives では<code>link</code>の書き方にバリエーションがあるので、ざっと眺めておく。</p>

<p>``` javascript
myModule.directive(&lsquo;returnLinkFunction&rsquo;, function () {
  return function(scope, element, attrs) {</p>

<pre><code>// ...
</code></pre>

<p>  };
});
<code>``
まず、単に</code>function<code>を return するだけという書き方ができて、これは</code>link<code>プロパティだけを持つオブジェクトを返しているのと同じことになる。</code>link`以外のプロパティを指定する必要が無ければ、こう書くことでシンプルなコードにできる。</p>

<p>``` javascript
myModule.directive(&lsquo;usingLinkOption&rsquo;, function () {
  return {</p>

<pre><code>link: function(scope, element, attrs) {
  // ...
}
</code></pre>

<p>  };
});
<code>``
これはオブジェクト（DDO: Directive Definition Object）を返す書き方で、</code>compile`プロパティを使わない場合の書き方。</p>

<p>``` javascript
myModule.directive(&lsquo;usingCompileOption&rsquo;, function () {
  return {</p>

<pre><code>compile: function(element, attrs) {
  // ...
  return function(scope, element, attrs) {
    // ...
  };
}
</code></pre>

<p>  };
});
<code>``
最後に、</code>compile<code>プロパティを使う場合の書き方で、</code>compile<code>function で return している</code>function<code>が</code>link`function として扱われることになる。</p>

<h2>３回目へ向けて</h2>

<p>この２回目で compile と link の使い分けができるようになったので、ここまでの知識でとりあえず directive を使っていろいろ実装していけるんじゃないかと思う。</p>

<p>けれども、<code>replace</code> <code>transclude</code> <code>scope</code> <code>controller</code> <code>require</code>といった大事なプロパティを抑えてないので、ここで終わったら directive こわいままになっちゃうので、<a href="/blog/2013/11/27/angularjs-custom-directives/">３回目</a>に続く。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Directive なんてこわくない（その１）]]></title>
    <link href="http://angularjsninja.com/blog/2013/11/20/angularjs-custom-directives/"/>
    <updated>2013-11-20T12:08:23+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/11/20/angularjs-custom-directives</id>
    <content type="html"><![CDATA[<hr />

<p>独自（カスタム）directive の話は複雑でボリュームがあるので、何回かに分けることにして、まずは<a href="http://angularjsninja.com/blog/2013/11/19/angularjs-nginclude/">前回の ng-include</a> の流れを受けて、とりあえず HTML を分割することから始めてみよう。</p>

<h2>単にテンプレート部分を Directive にするには</h2>

<p>繰り返し出てくるコード部分を、テンプレートとして directive で宣言するサンプルコード。</p>

<p>``` html</p>

<div ninja-customer></div>


<p><code>
</code> javascript
angular.module(&lsquo;Ninja&rsquo;, [])
  .directive(&lsquo;ninjaCustomer&rsquo;, function() {</p>

<pre><code>return {
  templateUrl: 'partials/ninja-customer.html'
};
</code></pre>

<p>  });
```
こんだけなので、まあどってことない。これだけなら ng-include のほうがラクでいいやんってことになるかな。でもまあ、とりあえずこんだけしか書かなくても directive として動作するのかってことを見ておく。</p>

<!-- more -->


<h2>要素として使う Directive としたければ</h2>

<p>デフォルトでは属性（<code>restrict: 'A'</code>）として使う directive として作られる。なので、要素として HTML で指定する directive にしたければ、<code>restrict</code> オプションが必要になる。</p>

<p><code>html
&lt;ninja-customer&gt;&lt;/ninja-customer&gt;
</code>
``` javascript
angular.module(&lsquo;Ninja&rsquo;, [])
  .directive(&lsquo;ninjaCustomer&rsquo;, function() {</p>

<pre><code>return {
  restrict: 'E',
  templateUrl: 'partials/ninja-customer.html'
};
</code></pre>

<p>  });
<code>``
</code>restrict<code>オプションを指定する場合の選択肢として、覚えておけばいいのは以下の３種類。</code>A<code>は Attribute（属性）で、</code>E`は Element（要素）。</p>

<p><code>javascript
restrict: 'A' // 属性のみ（デフォルト）
restrict: 'E' // 要素のみ
restrict: 'AE' // 属性または要素
</code></p>

<p>属性と要素、どちらを選択するかについては、まとまったコンポーネントとして directive を位置付けるケースでは要素とし、既存の要素に機能を足すようなケースでは属性とするのがいいぽい。</p>

<p>Directive の定義で return するオブジェクトに、オプションとして記述していく記述スタイルで、<code>restrict</code>や<code>templateUrl</code>の他に、<code>link</code>、<code>replace</code>、<code>transclude</code>、<code>scope</code>、<code>controller</code>など使えるオプションがあるんだけれど、ひとまず後回し。</p>

<h2>どんなときにカスタム Directive を作るか</h2>

<p>Controllers と AngularJS 標準の各種 directive を使えば大抵のことはできてしまうのと、directive の仕様が複雑すぎてわかりにくということで、AngularJS を使っていてもカスタム directive は手付かずだったり、作ってみてもこれでいいのか自信ないなって感じになりがちかなと。</p>

<p>カスタム directive は、例えば jQuery（jqLite）などで直接 DOM を操作したいときや、繰り返し出てくるコードをリファクタリングしてまとめたいときに利用するのがいい。</p>

<p>なお、AngularJS のアプリケーションでも jQuery を利用できることについては、過去エントリ「<a href="http://angularjsninja.com/blog/2013/10/05/jquery-to-angularjs/">jQuery と AngularJS</a>」に記載しているように、jQuery を先読みすればその jQuery が使え、jQuery 無しでも AngularJS が持つ jQuery のサブセット jqLite で DOM 操作のコードが同じように記述できる。</p>

<p>さらに、複数のプロジェクトでの再利用を目指してコンポーネント化するなら <a href="http://angular-ui.github.io/bootstrap/">UI Bootstrap</a> のコードを参考に、複雑な directive の作成に取り組んでいきたいところ。</p>

<h2>Directive とは何か</h2>

<p>AngularJS で一番強力な機能と言え、HTML が持っていない意味合いや振る舞いを加えるように使うことができる。AngularJS 標準の<code>ng-bind</code>や<code>ng-model</code>、<code>ng-view</code>とかはすべて directive であって、controllers や services に記述したアプリケーションロジックを、属性や要素として DOM 要素にバインドできるようになる。</p>

<p>簡単に言うと、データバインドするモデルやイベントハンドリングするロジックを、DOM に紐付けるためのものということ。</p>

<h2>標準 Directive</h2>

<p>AngularJS には標準（ビルトイン）の directives がたくさん存在し、公式サイトの <a href="http://docs.angularjs.org/api/ng#directive">ng (core module) ページ Directive</a> には、<code>ng-include</code>、<code>ng-controller</code>、<code>ng-click</code>などよく使う<code>ng</code>で始まるものだけでなく、普通の HTML のように見える<code>a</code>、<code>form</code>や<code>input</code>なども directive として記載されている。</p>

<p>たとえば<code>a</code>については href 属性値が空のときにはデフォルトの動作が防止されるよう処理されたり、<code>form</code>だと name 属性があれば scope のほうでその名前で参照できるように処理されたりする。</p>

<p>form には HTML で form を入れ子にできるよう<code>ng-form</code>があったり、<code>ng-submit</code>の機能、<code>ng-invalid</code>や<code>ng-dirty</code>などの機能についても触れたくなるけれど、その辺のことはまた別の機会に。</p>

<h2>Directives の記述</h2>

<p>Directives は JavaScript では camelCase で宣言し、HTML では小文字ハイフン区切りの lower-case で参照する。</p>

<p>HTML では４種類の参照方法があるものの、基本的には要素か属性として記述する以下の２種類。</p>

<p>``` html
&lt;my-directive>&lt;/my-directive></p>

<div my-directive></div>


<p>```</p>

<p>HTML の validation ツールを使いたければ<code>data-</code>を付けておくといい。</p>

<p><code>html
&lt;span ng-bind="name"&gt;&lt;/span&gt;
&lt;span data-ng-bind="name"&gt;&lt;/span&gt;
</code></p>

<h2>Directives の接頭辞</h2>

<p>カスタム directive の名前には、念のため接頭辞（ng を避ける）を付けておくほうがいいかもしれない。将来、偶然 HTML 標準として追加される要素名と重なってしまうケースや、AngularUI や AngularStrap などサードパーティ製の directives と重なってしまうケースもありえるので。</p>

<h2>次回へ向けて</h2>

<p>え、そんなちょっとしか記述しなくても directive として成立してるんだ、ってことを見てもらうのが初回の目的なので、ひとまずここで終了。</p>

<p>こんなとこで終わったら、directive こわいままになっちゃうので、なんとしてでも<a href="/blog/2013/11/22/angularjs-custom-directives/">次回</a>も続けないと。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJSでHTMLを分割するのにお手軽なng-include]]></title>
    <link href="http://angularjsninja.com/blog/2013/11/19/angularjs-nginclude/"/>
    <updated>2013-11-19T09:17:00+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/11/19/angularjs-nginclude</id>
    <content type="html"><![CDATA[<hr />

<h2>AngularJS で HTML を分割するのにお手軽な ng-include</h2>

<p>``` html</p>

<div ng-include="'partials/sidebar.html'"></div>


<p><code>
</code> html
&lt;ng-include src=&ldquo;&lsquo;partials/sidebar.html&rsquo;&rdquo;>&lt;/ng-include>
```</p>

<p>ポイントとしては、属性値に文字列を渡す必要があって、ダブルクオートの内側にシングルクオートを記述すること。</p>

<p>変数を渡して、可変にもできる。</p>

<p><code>javascript
$scope.sidebarUrl = 'partials/sidebar.html';
</code>
``` html</p>

<div ng-include="sidebarUrl"></div>


<p>```</p>

<p><code>ng-include</code>で表示する HTML 部分でも、もちろん普通に AngularJS の管理下にあり、データバインドも効く。分割したフラグメント専用に controller の scope を作るなら、<code>ng-controller</code>も指定できる。</p>

<p>``` html</p>

<div ng-include="'partials/sidebar.html'" ng-controller="SidebarCtrl"></div>


<p>```</p>

<!-- more -->


<h2>分割した HTML は $templateCache でキャッシュしてくれる</h2>

<p>分割した HTML は、通信して取得した時点で AngularJS が $templateCache で（メモリに）保持するため、分割されている部分を表示するたびに取得する通信が発生するわけではない。</p>

<p>かつ、必要となった時点で取得しにいくレイジーローディングなので、ユーザがまったく表示しない部分であれば、１度も取得しにいかないので効率的でもある。</p>

<p>一方で、Grunt などでビルドする時に、この HTML フラグメントを一つのファイルにしてしまい、一括してロードさせることでネットワークでのロスを下げるという方向で工夫もできる。</p>

<p>スクリプトとして HTML テンプレートを記述する場合は、script 要素に<code>type</code>と<code>id</code>を指定する。</p>

<p><code>html
&lt;scipt type="text/ng-template" id="templateId.html"&gt;
  This is the content of the template
&lt;/script&gt;
</code></p>

<p>初期処理でテンプレートを<code>$templateCache</code>に<code>put</code>するようにしておけば、その分だけ操作性の向上も期待できる。</p>

<p><code>javascript
var myApp = angular.module('Ninja', []);
myApp.run(function($templateCache) {
  $templateCache.put('templateId.html', 'This is the content of the template');
});
</code></p>

<p>お手軽に断片化できる ng-include の紹介でしたが、HTML を分割する手段としては他にも ng-view の routing で templateUrl を指定することや、custom directive を作成することもできるので、次回以降でその辺も触れる（たぶん）。</p>
]]></content>
  </entry>
  
</feed>
