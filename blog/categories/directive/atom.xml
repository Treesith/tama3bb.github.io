<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: directive | AngularJS Ninja]]></title>
  <link href="http://angularjsninja.com/blog/categories/directive/atom.xml" rel="self"/>
  <link href="http://angularjsninja.com/"/>
  <updated>2014-02-05T17:58:51+09:00</updated>
  <id>http://angularjsninja.com/</id>
  <author>
    <name><![CDATA[Akihito Tamagawa]]></name>
    <email><![CDATA[tama3bb@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AngularJSのng-ifで文字列を使うなら !! を付けよう]]></title>
    <link href="http://angularjsninja.com/blog/2014/02/05/ngif-string-caveat/"/>
    <updated>2014-02-05T17:44:16+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/02/05/ngif-string-caveat</id>
    <content type="html"><![CDATA[<hr />

<h2>&lsquo;0&rsquo; が表示されない…</h2>

<p><code>ng-if</code> あるいは、<code>ng-show</code>や<code>ng-hide</code>を使うときに、string 値の有無で表示判定を記述することもある。</p>

<p>
``` html</p>

<p ng-if="model.value">{{model.label}}</p>


<p>```
</p>

<p>そんなとき、<code>model.value</code>の値が<code>'0'</code>だったらどうなるか。</p>

<p>なんと、表示されない…。</p>

<!-- more -->


<h2>&lsquo;0&rsquo; だけじゃない</h2>

<p>この現象、<code>'0'</code>だけでなく、<code>'f'</code> <code>'no'</code> <code>'n'</code>といった文字列（大文字・小文字問わず）の場合であっても表示されない。</p>

<p>angular.js のコードはこうなってる。</p>

<p>``` javascript
function toBoolean(value) {
  if (typeof value === &lsquo;function&rsquo;) {</p>

<pre><code>value = true;
</code></pre>

<p>  } else if (value &amp;&amp; value.length !== 0) {</p>

<pre><code>var v = lowercase("" + value);
value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');
</code></pre>

<p>  } else {</p>

<pre><code>value = false;
</code></pre>

<p>  }
  return value;
}
```</p>

<h2>boolean にしちゃっておこう</h2>

<p>ということで、文字列の有無で判定させたいだけってときは<code>!!</code>を付けときましょう。boolean とか object の場合でも<code>!!</code>付ける方針にしとくのがラクでいいかな。</p>

<p>
``` html</p>

<p ng-if="!!model.value">{{model.label}}</p>


<p>```
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS で Enter キーを検出するコード]]></title>
    <link href="http://angularjsninja.com/blog/2014/02/03/angularjs-event-on-enter/"/>
    <updated>2014-02-03T18:28:23+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/02/03/angularjs-event-on-enter</id>
    <content type="html"><![CDATA[<hr />

<p>テキストボックスなどで、Enter キーによるイベント処理を記述するコード例をいくつか。</p>

<h2>$event オブジェクト</h2>

<p><code>ng-keydown</code>などの directive を利用する際には、<code>$event</code>でイベントオブジェクトを利用。</p>

<p>``` javascript
$scope.comments = [];
$scope.handleKeydown = function(e) {
  if (e.which !== 13) {</p>

<pre><code>$scope.comments.push($scope.newComment);
$scope.newComment = '';
</code></pre>

<p>  }
}
```</p>

<p>``` html
<input type="text" ng-model="newComment" ng-keydown="handleKeydown($event)"></p>

<p><ul>
  <li ng-repeat="comment in comments"></li>
<ul>
```</p>

<p><!-- more --></p>

<h2>カスタム directive でのイベント処理</h2>

<p>カスタム directive を定義する場合は、jQuery と同じような感じでバインド。</p>

<p>``` javascript
myApp.directive(&lsquo;handleKeydown&rsquo;, function() {
  return {</p>

<pre><code>require: 'ngModel',
link: function(scope, element, attrs, modelCtrl) {
  element.bind('keydown', function(e) {
    if (e.which === 13) {
      scope.$apply(function() {
        scope.comments.push(scope.newComment);
        scope.newComment = '';
      });
    }
  });
}
</code></pre>

<p>  };
});
```</p>

<p><code>html
&lt;input type="text" ng-model="newComment" handle-keydown&gt;
</code></p>

<h2>form（ng-form）の submit</h2>

<p>最後に持ってきたものの、form の submit で実現することを真っ先に検討するのが吉。Enter キーも処理されるし、テキストボックスがたくさんあっても無問題。</p>

<p><code>html
&lt;form ng-submit="handleKeydown()"&gt;
  &lt;input type="text" ng-model="newComment"&gt;
&lt;/form&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Directive なんてこわくない（その４）]]></title>
    <link href="http://angularjsninja.com/blog/2013/11/29/angularjs-custom-directives/"/>
    <updated>2013-11-29T15:33:32+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/11/29/angularjs-custom-directives</id>
    <content type="html"><![CDATA[<hr />

<h2>controller, require</h2>

<p><a href="/blog/2013/11/20/angularjs-custom-directives/">その１</a>、<a href="/blog/2013/11/22/angularjs-custom-directives/">その２</a>、<a href="/blog/2013/11/27/angularjs-custom-directives/">その３</a>に引き続き、今回もカスタム directive について。</p>

<p>今回のサンプルコードは、UI Bootstrap の <a href="https://github.com/angular-ui/bootstrap/tree/master/src/tabs">Tabs</a> からの一部抜粋で、<code>controller</code> <code>require</code>オプションについて見ていく。</p>

<p>``` javascript tabs.js
angular.module(&lsquo;ui.bootstrap.tabs&rsquo;, [])
.controller(&lsquo;TabsetController&rsquo;, [&lsquo;$scope&rsquo;, function TabsetCtrl($scope) {
  var ctrl = this,</p>

<pre><code>  tabs = ctrl.tabs = $scope.tabs = [];
</code></pre>

<p>  ctrl.select = function(tab) {</p>

<pre><code>angular.forEach(tabs, function(tab) {
  tab.active = false;
});
tab.active = true;
</code></pre>

<p>  };
  // &hellip;
}])</p>

<p>.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>restrict: 'EA',
transclude: true,
replace: true,
require: '^tabset',
scope: {},
controller: 'TabsetController',
templateUrl: 'template/tabs/tabset.html',
compile: function(elm, attrs, transclude) {
  return function(scope, element, attrs, tabsetCtrl) {
    // ...
  };
}
</code></pre>

<p>  };
})</p>

<p>.directive(&lsquo;tab&rsquo;, [&lsquo;$parse&rsquo;, function($parse) {
  return {</p>

<pre><code>require: '^tabset',
restrict: 'EA',
replace: true,
templateUrl: 'template/tabs/tab.html',
transclude: true,
scope: {
  heading: '@',
  onSelect: '&amp;select',
  onDeselect: '&amp;deselect'
},
controller: function() {},
compile: function(elm, attrs, transclude) {
  return function postLink(scope, elm, attrs, tabsetCtrl) {
    // ...
    scope.$watch('active', function(active) {
      setActive(scope.$parent, active);
      if (active) {
        tabsetCtrl.select(scope);
        scope.onSelect();
      } else {
        scope.onDeselect();
      }
    });
    // ...
    scope.select = function() {
      if (!scope.disabled ) {
        scope.active = true;
      }
    };
    tabsetCtrl.addTab(scope);
    scope.$on('$destroy', function() {
      tabsetCtrl.removeTab(scope);
    });
    // ...
  };
}
</code></pre>

<p>  };
}])
```</p>

<!-- more -->


<h2>controller</h2>

<p>directive にも<code>ng-controller</code>で利用するときに定義するのと同じような<code>controller</code>を記述でき、<code>$scope</code>や<code>$http</code>などをインジェクト（DI）することもできる。directive の場合でも、<code>controller</code>では DOM 操作するコードは記述しないようにし、<code>compile</code>または <code>link</code>のほうに記述する。</p>

<p>なお、directive の<code>controller</code>には、モジュールで定義した<code>controller</code>の名前を記述することができる。</p>

<p>``` javascript
.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>...,
controller: 'TabsetController',
...
</code></pre>

<p>  };
})
```</p>

<p>注意すべき点としては、再利用されるコンポーネントとして directive を作成する場合、<code>controller</code>に付ける名前が重複されにくい名前にしておくこと。</p>

<p><code>controller</code>に名前を付けずに、直接 function を記述することもできる。</p>

<p>``` javascript
.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>...,
controller: ['$scope', function($scope) {
  // ...
}],
...
</code></pre>

<p>  };
})
```</p>

<p><code>$scope</code>だけでなく<code>$http</code>や<code>$timeout</code>などをインジェクト（DI）できる。また、directive の<code>controller</code>では<code>$element</code> <code>$attrs</code> <code>$transclude</code>の service をインジェクトできるようになっている。</p>

<p><code>link</code>でも<code>controller</code>でも、どちらでも同じような処理を記述することができそうに思う。違う点は、DI を利用できるか否かと、処理のタイミング（<code>controller</code>が先で、<code>link</code>が後）。使い分けのヒントとしては、子要素など別の directive から呼び出すのであれば<code>controller</code>として API を公開する感じで実装し、そうでなければ<code>link</code>で実装するという感じで。</p>

<h2>require</h2>

<p>ネストされた directive から親の directive の<code>controller</code>で定義された API を呼び出すには<code>require</code>が必要となる。</p>

<p>上のコード例では、<code>require: '^tabset'</code>の記述があり、これによって<code>tabset</code> directive の<code>controller</code>である<code>tabsetCtrl</code>を参照して API を利用できるようになる。</p>

<p>``` javascript
compile: function(elm, attrs, transclude) {
  return function postLink(scope, elm, attrs, tabsetCtrl) {</p>

<pre><code>tabsetCtrl.select(scope);
tabsetCtrl.addTab(scope);
tabsetCtrl.removeTab(scope);
</code></pre>

<p>  };
}
```</p>

<p>なお、<code>^</code>を付けない場合、親階層ではなく directive を指定した要素の<code>controller</code>を探すこととなる。このケースでよく使うのは<code>require: 'ngModel'</code>で、directive と同じ要素に<code>ng-model="..."</code>の記述があることを前提として実装できることになる。</p>

<p>同じ要素に<code>ng-model</code>属性の記述が無い場合、こんなエラーになる。</p>

<p><code>
Error: [$compile:ctreq] Controller 'ngModel', required by directive 'input', can't be found!
</code></p>

<p>このエラーを発生させる必要が無いなら、<code>require: '?ngModel'</code>のように<code>?</code>を付けて記述する。</p>

<h2>これでもうカスタム directive を書ける</h2>

<p>この４回目で<code>controller</code>と<code>require</code>を使って、複数の directive でコンポーネントを構成することについての理解も進んだので、どんどん directive を活用していこう！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Directive なんてこわくない（その３）]]></title>
    <link href="http://angularjsninja.com/blog/2013/11/27/angularjs-custom-directives/"/>
    <updated>2013-11-27T12:02:43+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/11/27/angularjs-custom-directives</id>
    <content type="html"><![CDATA[<hr />

<h2>replace, transclude, scope</h2>

<p><a href="/blog/2013/11/20/angularjs-custom-directives/">前々回</a>、<a href="/blog/2013/11/22/angularjs-custom-directives/">前回</a>に引き続き、今回もカスタム directive について。</p>

<p>今回のサンプルコードは、UI Bootstrap の <a href="https://github.com/angular-ui/bootstrap/tree/master/src/alert">Alert</a> からで、<code>replace</code> <code>transclude</code> <code>scope</code>オプションについて見ていく。</p>

<p>``` javascript alert.js
angular.module(&ldquo;ui.bootstrap.alert&rdquo;, []).directive(&lsquo;alert&rsquo;, function() {
  return {</p>

<pre><code>restrict:'EA',
templateUrl:'template/alert/alert.html',
transclude:true,
replace:true,
scope: {
  type: '=',
  close: '&amp;'
},
link: function(scope, iElement, iAttrs) {
  scope.closeable = "close" in iAttrs;
}
</code></pre>

<p>  };
});
<code>
</code> html template/alert/alert.html</p>

<div class="alert" ng-class="type && 'alert-' + type">
    <button ng-show="closeable" type="button" class="close" ng-click="close()">&times;</button>
    <div ng-transclude></div>
</div>


<p><code>

</code> html
<alert ng-repeat="alert in alerts" type="alert.type" close="closeAlert($index)">
  {{alert.msg}}
</alert>
```
</p>

<!-- more -->


<h2>replace</h2>

<p><code>template</code>または<code>templateUrl</code>で指定された HTML のフラグメントは、デフォルトでは directive を指定した要素の内側に append される。</p>

<p>``` html
<alert ...>
  <div class='alert' ...></p>

<pre><code>...
</code></pre>

<p>  </div>
</alert>
```</p>

<p>このコード例のように、directive を要素として指定できるよう<code>restrict</code>に<code>'E'</code>を含めるときには、HTML として不適当な要素名が記述されることになるため、<code>replace: true</code>を指定する前提で directive を設計しよう。</p>

<p><code>replace: true</code> を指定することによって、directive を指定した要素自体を置き換えることができるので、directive がコンパイルされた結果は以下のようなコードとなる。</p>

<p>
``` html</p>

<div ng-class="type && 'alert-' + type" class="alert ng-scope" close="closeAlert($index)" type="alert.type" ng-repeat="alert in alerts">
    <button ng-click="close()" class="close" type="button" ng-show="closeable">×</button>
    <div ng-transclude=""><span class="ng-scope ng-binding">Another alert!</span></div>
</div>


<p>```
</p>

<p><code>replace: true</code> の場合、 directive を指定した要素にある属性は、テンプレート側のルート要素にコピーされる。なので、<code>ng-repeat="alert in alerts"</code>や<code>type="alert.type"</code>、<code>close="closeAlert($index)"</code>も有効となる。</p>

<p>両方に class 属性があるケースでは、両方の class 属性値をいい感じにマージしてくれる。</p>

<h2>transclude</h2>

<p><code>transclude</code>には、<code>true</code>または<code>'element'</code>を指定でき、directive とした要素の内容を、テンプレートの一部として利用できる。</p>

<p><code>javascript
transclude: true // directive 要素の内容（内側）をテンプレートで利用
transclude: 'element' // directive 要素ごとテンプレートで利用
</code></p>

<p>テンプレート側に ng-transclude を指定した要素の内側に append できる。上記サンプルコードの例では、<code>{{alert.msg}}</code>が<code>&lt;div ng-transclude&gt;</code>の内側に append される。</p>

<p>上記コード例では、<code>alert</code>directive の内側部分<code>{{alert.msg}}</code>が、<code>ng-transclude</code>に append されていることがわかる（<code>alert.msg: 'Another alert!'</code>という前提）。</p>

<h2>scope</h2>

<p>scope には、以下の３種類の指定方法がある。</p>

<p><code>javascript
scope: false // directive が利用される場所での scope を利用（デフォルト）
scope: true // directive が利用される場所での scope を継承する、新たな scope を生成
scope: {...} // directive が利用される場所での scope を継承しない、独立した新たな scope を生成
</code></p>

<p><code>scope: true</code>が指定されている代表的な directive は<code>ng-controller</code>で、ご存知のとおり<code>ng-controller</code>を利用すると scope を継承する新たな scope が生成される。これにより、親の scope にあるデータや function を利用したり、オーバーライドしたりできるようになる。</p>

<p>一方で、コンポーネントとして再利用可能な directive を設計するには、directive を利用する場所での scope による影響を受けない分離・独立した scope を生成したい。</p>

<p><code>javascript
scope: {
  name: '@', // interpolate（値、string）
  info: '=', // data bind
  cancel: '&amp;' // expression（function）
}
</code>
このように、<code>scope</code>にオブジェクトを記述することで、この directive が利用されるたびに<code>name</code> <code>info</code> <code>cancel</code>のみ存在する新たな scope が生成される。</p>

<p>なお、directive を利用する側と、テンプレート側とで異なる名前を使いたいときは、以下のように記述することができる。
<code>javascript
scope: {
  customerInfo: '=info'
}
</code>
こうすることで、テンプレート内では<code>customerInfo</code>を、directive を利用する要素での属性名には<code>info</code>を利用できるようになる。</p>

<h2>４回目へ向けて</h2>

<p>この３回目で、再利用のための directive を記述する方法が理解できた。もう Directive なんてこわくない！</p>

<p>なんだけど、<a href="/blog/2013/11/29/angularjs-custom-directives/">４回目</a>でも引き続き、<code>controller</code> <code>require</code>といった directive のプロパティを扱う。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Directive なんてこわくない（その２）]]></title>
    <link href="http://angularjsninja.com/blog/2013/11/22/angularjs-custom-directives/"/>
    <updated>2013-11-22T13:37:02+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/11/22/angularjs-custom-directives</id>
    <content type="html"><![CDATA[<hr />

<h2>compile と link</h2>

<p><a href="/blog/2013/11/20/angularjs-custom-directives/">前回</a>に引き続き、今回もカスタム directive について。</p>

<p>２回目の今回は、<code>compile</code>と<code>link</code>の使い分けについて。</p>

<h2>compile のサンプルコード</h2>

<p>まずは<code>compile</code>を利用するサンプルコードを、『<a href="http://www.amazon.co.jp/dp/B00EQ67J30">Mastering Web Application Development with AngularJS</a>』から抜粋して見ていく。</p>

<p>このコードでは、Bootstrap の理由を前提として、以下に示すように Bootstrap でのボタンデザインに必要な CSS class の値を追加する処理を、<code>compile</code>で実装している。</p>

<p>``` javascript
myModule.directive(&lsquo;button&rsquo;, function() {
  return {</p>

<pre><code>restrict: 'E',
compile: function(element, attrs) {
  element.addClass('btn');
  if (attrs.type === 'submit') {
    element.addClass('btn-primary');
  }
  if (attrs.size) {
    element.addClass('btn-' + attrs.size);
  }
}
</code></pre>

<p>  };
});
```</p>

<ul>
<li><code>&lt;button&gt;</code>の class 属性に<code>btn</code>を追加</li>
<li><code>&lt;button type="submit"&gt;</code>のように <code>type="submit"</code>がある場合には、class 属性に<code>btn-primary</code>を追加</li>
<li><code>&lt;button size="..."&gt;</code>のように size 属性がある場合には、<code>btn-large</code>など、<code>btn-</code> と size 属性で指定した文字列を組み合わせた文字列を class 属性に追加</li>
</ul>


<p>コードからわかるように、compile オプションの function 第１引数にある<code>element</code>は、jQuery（jqLite）オブジェクトになっているので、直接 jQuery の API を利用できる。つまり<code>$(element)</code>や、<code>$(button)</code>などとしてやる必要はない。</p>

<p>第２引数の<code>attrs</code>では<code>attrs.size</code>のようにドット区切りで属性値にアクセスできるので、HTML テンプレート側の値を簡単に参照することができる。</p>

<!-- more -->


<h2>compile の流れ</h2>

<p>AngularJS が HTML テンプレートをコンパイルするために、標準の directives とカスタム定義した directives のすべてを、DOM の要素・属性・コメント・CSS class から探し出す。各 directive の<code>compile</code>function を呼び出し、<code>compile</code>function から返される<code>link</code>function を後で呼び出すために集めていく流れとなる。</p>

<p>なお、directives をコンパイルしていく処理の順序は<code>priority</code>の大きい順となるが、これについてはまた別の機会に先送り。</p>

<p>重要なポイントとしては、<code>compile</code>の処理は scope ができる前の処理であり、<code>compile</code>function では scope を利用できない。</p>

<p>すべてのコンパイル処理が終わった後、生成した scope を付けて<code>link</code>function を呼び出す流れとなり、この時点で<code>link</code>function の scope を利用した DOM との間での双方向バインドが効くことになる。</p>

<h2>compile と link の使い分け</h2>

<p><code>ng-repeat</code>の内側にある directive というケースなど、同じ directive が繰り返し使われることになるような場合では、<code>compile</code>の function は<code>ng-repeat</code>の繰り返しに関係なく一度だけ呼び出されるのに対し、<code>link</code>の function はイテレーションのたびに呼び出されることになる。</p>

<p>これは、scope のデータや双方向バインドに依存ぜずに処理できる上記のサンプルコードのようなケースであれば、<code>compile</code>を使うことで同じ処理を繰り返す無駄を省くように最適化できることになる。</p>

<p><code>compile</code>と<code>link</code>の両方を指定した場合には<code>link</code>が無視される仕様になっているため、両方を利用した実装をしたい場合には<code>compile</code>function から<code>link</code>function を return するよう実装することになる。</p>

<h2>link のサンプルコード</h2>

<p>ここから、最もよく利用することになる<code>link</code>の書き方について見ていく。</p>

<p>``` javascript
myModule.directive(&lsquo;myDirective&rsquo;, function () {
  return {</p>

<pre><code>link: function (scope, element) {
  scope.$watch('xxxVar', function () {
    // ...
  });
  scope.$on('xxxEvent', function () {
    // ...
  });
}
</code></pre>

<p>  };
});
<code>``
このように、</code>link<code>では、</code>scope`にあるモデルの変更を検知して処理することや、イベントに応じた処理を記述して、DOM や controller とのやり取りを記述していく。</p>

<h2>いろいろある link の書き方</h2>

<p>Directives では<code>link</code>の書き方にバリエーションがあるので、ざっと眺めておく。</p>

<p>``` javascript
myModule.directive(&lsquo;returnLinkFunction&rsquo;, function () {
  return function(scope, element, attrs) {</p>

<pre><code>// ...
</code></pre>

<p>  };
});
<code>``
まず、単に</code>function<code>を return するだけという書き方ができて、これは</code>link<code>プロパティだけを持つオブジェクトを返しているのと同じことになる。</code>link`以外のプロパティを指定する必要が無ければ、こう書くことでシンプルなコードにできる。</p>

<p>``` javascript
myModule.directive(&lsquo;usingLinkOption&rsquo;, function () {
  return {</p>

<pre><code>link: function(scope, element, attrs) {
  // ...
}
</code></pre>

<p>  };
});
<code>``
これはオブジェクト（DDO: Directive Definition Object）を返す書き方で、</code>compile`プロパティを使わない場合の書き方。</p>

<p>``` javascript
myModule.directive(&lsquo;usingCompileOption&rsquo;, function () {
  return {</p>

<pre><code>compile: function(element, attrs) {
  // ...
  return function(scope, element, attrs) {
    // ...
  };
}
</code></pre>

<p>  };
});
<code>``
最後に、</code>compile<code>プロパティを使う場合の書き方で、</code>compile<code>function で return している</code>function<code>が</code>link`function として扱われることになる。</p>

<h2>３回目へ向けて</h2>

<p>この２回目で compile と link の使い分けができるようになったので、ここまでの知識でとりあえず directive を使っていろいろ実装していけるんじゃないかと思う。</p>

<p>けれども、<code>replace</code> <code>transclude</code> <code>scope</code> <code>controller</code> <code>require</code>といった大事なプロパティを抑えてないので、ここで終わったら directive こわいままになっちゃうので、<a href="/blog/2013/11/27/angularjs-custom-directives/">３回目</a>に続く。</p>
]]></content>
  </entry>
  
</feed>
