<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: AngularJS | AngularJS Ninja]]></title>
  <link href="http://angularjsninja.com/blog/categories/angularjs/atom.xml" rel="self"/>
  <link href="http://angularjsninja.com/"/>
  <updated>2013-12-10T02:08:34+09:00</updated>
  <id>http://angularjsninja.com/</id>
  <author>
    <name><![CDATA[Akihito Tamagawa]]></name>
    <email><![CDATA[tama3bb@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AngularJSのHTMLバインド  ではundefinedを気にしない]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/10/angularjs-expressions-forgiving/"/>
    <updated>2013-12-10T01:46:47+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/10/angularjs-expressions-forgiving</id>
    <content type="html"><![CDATA[<hr />

<h2>Forgiving</h2>

<p><a href="http://docs.angularjs.org/guide/expression">AngularJS: Expressions</a> ページで <a href="http://docs.angularjs.org/guide/expression#property-evaluation_forgiving">Forgiving</a> として説明されているように、HTML（テンプレート）で記述する AngularJS のバインド部分（<code>{{ result.title.value }}</code> や<code>ng-if=“result.tags.length”</code>）では、result、title、tags が、undefined や null でないかや object かどうかということを考慮したコードにしなくていい。</p>

<p>result が通信してサーバから取得するデータであれば、レスポンスが返るまでの間 result は undefined の状態になるけど、だからと言って<code>{{ ((result || {}).title || {}).c }}</code>とか、<code>result &amp;&amp; result.title &amp;&amp; result.title.value</code>のようにコーディングしなくていい。</p>

<!-- more -->


<h2>サンプル</h2>

<p>以下のサンプルでは、<code>ng-hide="result.hidden"</code>のとこで、result なんて定義してないので undefined だけど、エラーにならずに falsy として扱われている。</p>

<p><a class="jsbin-embed" href="http://jsbin.com/oTOMaFIJ/11/embed?html,output">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJSでちゃちゃっとアニメーションを試す]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/08/angularjs-nganimate/"/>
    <updated>2013-12-08T00:20:54+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/08/angularjs-nganimate</id>
    <content type="html"><![CDATA[<hr />

<h2>AngularJS 1.2.4</h2>

<p>AngularJS 1.2.4 がリリースされ、$animate 関連の <a href="https://github.com/angular/angular.js/blob/master/CHANGELOG.md#1.2.4">Bug Fixes</a> が入り ng-include をネストした ng-repeat でアニメーションが効かない問題も解消されたので、アニメーションをちゃちゃっと試す方法を紹介。</p>

<h2>angular-animate.js</h2>

<p>HTML に angular と angular-animate の js ファイルを記述する。</p>

<p>``` html</p>

<p><script src="angular.min.js">
<script src="angular-animate.min.js">
```</p>

<h2>ngAnimate モジュール</h2>

<p>依存モジュールとして <code>ngAnimate</code> を記述する。</p>

<p><code>javascript
angular.module('app', [ 'ngAnimate' ])
</code></p>

<h2>CSS 定義</h2>

<p>これだけでもうゴール間近で、あとはどんなアニメーションを適用するのかを考えて定義するだけ。</p>

<p>アニメーションを CSS で定義する方法と JavaScript で記述する方法があり、ここではちゃちゃっと試すのが簡単な CSS を例示する。</p>

<p><!-- more --></p>

<p><code>css
.ng-enter,
.ng-leave,
.ng-move {
  -webkit-transition: opacity 0.15s linear;
  transition: opacity 0.15s linear;
}
.ng-enter {
  opacity: 0;
}
.ng-enter.ng-enter-active {
  opacity: 1;
}
.ng-leave {
  opacity: 1;
}
.ng-leave.ng-leave-active {
  opacity: 0;
}
.ng-move {
  opacity: .5;
}
.ng-move.ng-move-active {
  opacity: 1;
}
</code></p>

<p>この CSS 定義だけで、<code>enter</code> <code>leave</code> <code>move</code>系の<code>ngRepeat</code> <code>ngView</code> <code>ngInclude</code> <code>ngSwitch</code> <code>ngIf</code> directives に fade（フェード）のアニメーションが適用される。</p>

<h2>アニメーションを限定的に適用</h2>

<p>ちゃちゃっとアニメーションを試してみるのにはさっきの CSS で OK だけど、アニメーションされすぎで気持ち悪いとか、アニメーションのせいでむしろ遅い UI に感じられるとか、テーブルタグなどで不自然なレンダリングになるとか…。</p>

<p>なので、ちゃんとアニメーションを使うときには CSS のセレクタに class name（以下では animated）を追加し、適用箇所を限定する。</p>

<p><code>css
.animated.ng-enter,
.animated.ng-leave,
.animated.ng-move {
  -webkit-transition: opacity 0.15s linear;
  transition: opacity 0.15s linear;
}
.animated.ng-enter {
  opacity: 0;
}
.animated.ng-enter.ng-enter-active {
  opacity: 1;
}
.animated.ng-leave {
  opacity: 1;
}
.animated.ng-leave.ng-leave-active {
  opacity: 0;
}
.animated.ng-move {
  opacity: .5;
}
.animated.ng-move.ng-move-active {
  opacity: 1;
}
</code></p>

<p>そして、HTML 側でアニメーションさせたい<code>ng-if</code>や<code>ng-repeat</code>を指定した要素の class 属性に <code>animated</code> を追記する。</p>

<p><code>html
&lt;div ng-if="model.visible" class="animated"&gt;...&lt;/div&gt;
</code></p>

<p>むやみやたらにアニメーションするのでなく、こうしてポイントポイントで上品に適用していくことを心掛けよう。</p>

<h2>サンプル</h2>

<p>
<a class="jsbin-embed" href="http://jsbin.com/EpiHEwuK/26/embed?output">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>
</p>

<h2>class 属性の変化</h2>

<p>class 属性が変化する流れを見ておく。</p>

<p><code>model.visible = false;</code>（非表示状態）のときがこのようなコードだとして、</p>

<p><code>html
&lt;div ng-if="model.visible" class="animated"&gt;...&lt;/div&gt;
</code></p>

<p><code>model.visible = true;</code>（表示に切替）になるとまず<code>ng-enter</code>が追加（<code>opacity: 0;</code>）されて、</p>

<p><code>html
&lt;div ng-if="model.visible" class="animated ng-enter"&gt;...&lt;/div&gt;
</code></p>

<p>その後すぐに<code>ng-enter-active</code>が追加（<code>opacity: 1;</code>）されることでアニメーションが開始する。CSS で定義している <code>transition: opacity 0.15s linear;</code>により 0.15s の速度でフェードしながら表示（fadeIn）され、</p>

<p><code>html
&lt;div ng-if="model.visible" class="animated ng-enter ng-enter-active"&gt;...&lt;/div&gt;
</code></p>

<p>要素の class 属性は元に戻る。</p>

<p><code>html
&lt;div ng-if="model.visible" class="animated"&gt;...&lt;/div&gt;
</code></p>

<p>その逆で表示から非表示になるときには、<code>ng-enter</code>の代わりに<code>ng-leave</code>と<code>ng-leave-active</code>が class 属性に追加される。</p>

<h2>アニメーションに対応する標準 directive</h2>

<p>以下の AngularJS 標準 directive には、アニメーションのための処理が実装されているので、表示・非表示が切り替わるタイミングで class 属性に先述したような値（<code>ng-enter</code>など）が反映される。</p>

<table>
<thead>
<tr>
<th>Directive </th>
<th> Supported Animations</th>
</tr>
</thead>
<tbody>
<tr>
<td>ngRepeat </td>
<td> enter, leave, move</td>
</tr>
<tr>
<td>ngView </td>
<td> enter, leave</td>
</tr>
<tr>
<td>ngInclude </td>
<td> enter, leave</td>
</tr>
<tr>
<td>ngSwitch </td>
<td> enter, leave</td>
</tr>
<tr>
<td>ngIf </td>
<td> enter, leave</td>
</tr>
<tr>
<td>ngClass </td>
<td> add, remove</td>
</tr>
<tr>
<td>ngShow / ngHide </td>
<td> add, remove (ng-hide class 値)</td>
</tr>
</tbody>
</table>


<p>もちろんカスタム directive でも $animate service を利用して標準 directive と同じようにアニメーションを実現できるけど、その方法についてはまた別の機会に。</p>

<h2>ngAnimate-animate.css</h2>

<p>最後に、<a href="https://daneden.me/animate/">animate.css</a> を AngularJS 1.2 で利用できるようにするドライバーモジュール <a href="https://github.com/yearofmoo/ngAnimate-animate.css">ngAnimate-animate.css</a> を紹介。</p>

<p>animate.css とこのモジュールを使えば、class 属性に <code>dn-fade</code> と記述するだけでフェードのアニメーションを利用できるようになる。その他いろいろなアニメーションも class 属性に指定するだけで試せる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectでもArrayでも回せるangular.forEach]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/06/angular-foreach/"/>
    <updated>2013-12-06T13:55:45+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/06/angular-foreach</id>
    <content type="html"><![CDATA[<hr />

<h2>angular.forEach</h2>

<p>AngularJS 標準の <a href="http://docs.angularjs.org/api/ng#function">Global API</a> から、<a href="http://docs.angularjs.org/api/angular.forEach">angular.forEach</a> の紹介。</p>

<p>angular.forEach は、Object でも Array でも回してくれる。</p>

<h2>angular.forEach(Object, Function)</h2>

<p><code>javascript
var user = { name: 'ninja', gender: 'unknown', weapons: [ ..., ... ] };
angular.forEach(user, function(value, key) {
  // ...
});
</code></p>

<p>オブジェクトを回す場合の Iterator function の引数は value, key の順。</p>

<h2>angular.forEach(Array, Function)</h2>

<p><code>javascript
var records = [ { ... }, { ... } ];
angular.forEach(records, function(record, i) {
  // ...
});
</code></p>

<p>配列を回す場合の Iterator function は第１引数が配列の中身で、第２引数が配列インデックスとなる。</p>

<!-- more -->


<h2>context の指定</h2>

<p>第３引数に Iteration function での context (this) を指定できる。</p>

<p>以下、公式サイトの <a href="http://docs.angularjs.org/api/angular.forEach">angular.forEach</a> ページに掲載されているコード。</p>

<p><code>javascript
var values = {name: 'misko', gender: 'male'};
var log = [];
angular.forEach(values, function(value, key) {
  this.push(key + ': ' + value);
}, log);
</code></p>

<p>この例だと、第３引数（context）に<code>log</code>を渡していて、この<code>log</code>が iterator の中での context <code>this</code>となる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJSのminify対策がngminでラクになる]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/03/angularjs-ngmin/"/>
    <updated>2013-12-03T11:15:48+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/03/angularjs-ngmin</id>
    <content type="html"><![CDATA[<hr />

<h2>AngularJS の minify 対策、めんどくさい</h2>

<p>AngularJS の JavaScript コードを minify するには、function の引数でインジェクト（DI）する各 services の名前を、文字列として重複させて記述する必要がある。</p>

<p>これって、めっちゃめんどくさい。あほらしすぎる。</p>

<h2>ngmin</h2>

<p>そこで <a href="https://github.com/btford/ngmin">ngmin</a> を使う。</p>

<p><code>
npm install -g ngmin
</code>
<code>
ngmin somefile.js somefile.annotate.js
</code></p>

<p>以下のコードが、</p>

<p>``` javascript somefile.js
angular.module(&lsquo;app&rsquo;, [])</p>

<p>  .controller(&lsquo;TodoCtrl&rsquo;, function($scope, $timeout, Projects) {</p>

<pre><code>// comments
$scope.createTask = function(task) {
  task.title = "New Task";
};
</code></pre>

<p>  });
```</p>

<p>ngmin 後は、こうなる。</p>

<p>``` javascript somefile.annotate.js
angular.module(&lsquo;app&rsquo;, []).controller(&lsquo;TodoCtrl&rsquo;, [
  &lsquo;$scope&rsquo;,
  &lsquo;$timeout&rsquo;,
  &lsquo;Projects&rsquo;,
  function ($scope, $timeout, Projects) {</p>

<pre><code>$scope.createTask = function (task) {
  task.title = 'New Task';
};
</code></pre>

<p>  }
]);
```</p>

<!-- more -->


<p>function の引数に記述している DI する services の名前が、自動的に文字列としても列挙されるので、これで minify 対策がラクになる！</p>

<p>その他、空行・コメント行削除、シングルクオート置換も実施される。</p>

<p><a href="https://github.com/btford/ngmin">ngmin</a> は <a href="http://gruntjs.com/">Grunt</a> タスク（<a href="https://github.com/btford/grunt-ngmin">grunt-ngmin</a>）としても利用可能で自動化できる！</p>

<p><blockquote><p>Life is too short to declare the names of dependencies!</p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Directive なんてこわくない（その４）]]></title>
    <link href="http://angularjsninja.com/blog/2013/11/29/angularjs-custom-directives/"/>
    <updated>2013-11-29T15:33:32+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/11/29/angularjs-custom-directives</id>
    <content type="html"><![CDATA[<hr />

<h2>controller, require</h2>

<p><a href="/blog/2013/11/20/angularjs-custom-directives/">その１</a>、<a href="/blog/2013/11/22/angularjs-custom-directives/">その２</a>、<a href="/blog/2013/11/27/angularjs-custom-directives/">その３</a>に引き続き、今回もカスタム directive について。</p>

<p>今回のサンプルコードは、UI Bootstrap の <a href="https://github.com/angular-ui/bootstrap/tree/master/src/tabs">Tabs</a> からの一部抜粋で、<code>controller</code> <code>require</code>オプションについて見ていく。</p>

<p>``` javascript tabs.js
angular.module(&lsquo;ui.bootstrap.tabs&rsquo;, [])
.controller(&lsquo;TabsetController&rsquo;, [&lsquo;$scope&rsquo;, function TabsetCtrl($scope) {
  var ctrl = this,</p>

<pre><code>  tabs = ctrl.tabs = $scope.tabs = [];
</code></pre>

<p>  ctrl.select = function(tab) {</p>

<pre><code>angular.forEach(tabs, function(tab) {
  tab.active = false;
});
tab.active = true;
</code></pre>

<p>  };
  // &hellip;
}])</p>

<p>.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>restrict: 'EA',
transclude: true,
replace: true,
require: '^tabset',
scope: {},
controller: 'TabsetController',
templateUrl: 'template/tabs/tabset.html',
compile: function(elm, attrs, transclude) {
  return function(scope, element, attrs, tabsetCtrl) {
    // ...
  };
}
</code></pre>

<p>  };
})</p>

<p>.directive(&lsquo;tab&rsquo;, [&lsquo;$parse&rsquo;, function($parse) {
  return {</p>

<pre><code>require: '^tabset',
restrict: 'EA',
replace: true,
templateUrl: 'template/tabs/tab.html',
transclude: true,
scope: {
  heading: '@',
  onSelect: '&amp;select',
  onDeselect: '&amp;deselect'
},
controller: function() {},
compile: function(elm, attrs, transclude) {
  return function postLink(scope, elm, attrs, tabsetCtrl) {
    // ...
    scope.$watch('active', function(active) {
      setActive(scope.$parent, active);
      if (active) {
        tabsetCtrl.select(scope);
        scope.onSelect();
      } else {
        scope.onDeselect();
      }
    });
    // ...
    scope.select = function() {
      if (!scope.disabled ) {
        scope.active = true;
      }
    };
    tabsetCtrl.addTab(scope);
    scope.$on('$destroy', function() {
      tabsetCtrl.removeTab(scope);
    });
    // ...
  };
}
</code></pre>

<p>  };
}])
```</p>

<!-- more -->


<h2>controller</h2>

<p>directive にも<code>ng-controller</code>で利用するときに定義するのと同じような<code>controller</code>を記述でき、<code>$scope</code>や<code>$http</code>などをインジェクト（DI）することもできる。directive の場合でも、<code>controller</code>では DOM 操作するコードは記述しないようにし、<code>compile</code>または <code>link</code>のほうに記述する。</p>

<p>なお、directive の<code>controller</code>には、モジュールで定義した<code>controller</code>の名前を記述することができる。</p>

<p>``` javascript
.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>...,
controller: 'TabsetController',
...
</code></pre>

<p>  };
})
```</p>

<p>注意すべき点としては、再利用されるコンポーネントとして directive を作成する場合、<code>controller</code>に付ける名前が重複されにくい名前にしておくこと。</p>

<p><code>controller</code>に名前を付けずに、直接 function を記述することもできる。</p>

<p>``` javascript
.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>...,
controller: ['$scope', function($scope) {
  // ...
}],
...
</code></pre>

<p>  };
})
```</p>

<p><code>$scope</code>だけでなく<code>$http</code>や<code>$timeout</code>などをインジェクト（DI）できる。また、directive の<code>controller</code>では<code>$element</code> <code>$attrs</code> <code>$transclude</code>の service をインジェクトできるようになっている。</p>

<p><code>link</code>でも<code>controller</code>でも、どちらでも同じような処理を記述することができそうに思う。違う点は、DI を利用できるか否かと、処理のタイミング（<code>controller</code>が先で、<code>link</code>が後）。使い分けのヒントとしては、子要素など別の directive から呼び出すのであれば<code>controller</code>として API を公開する感じで実装し、そうでなければ<code>link</code>で実装するという感じで。</p>

<h2>require</h2>

<p>ネストされた directive から親の directive の<code>controller</code>で定義された API を呼び出すには<code>require</code>が必要となる。</p>

<p>上のコード例では、<code>require: '^tabset'</code>の記述があり、これによって<code>tabset</code> directive の<code>controller</code>である<code>tabsetCtrl</code>を参照して API を利用できるようになる。</p>

<p>``` javascript
compile: function(elm, attrs, transclude) {
  return function postLink(scope, elm, attrs, tabsetCtrl) {</p>

<pre><code>tabsetCtrl.select(scope);
tabsetCtrl.addTab(scope);
tabsetCtrl.removeTab(scope);
</code></pre>

<p>  };
}
```</p>

<p>なお、<code>^</code>を付けない場合、親階層ではなく directive を指定した要素の<code>controller</code>を探すこととなる。このケースでよく使うのは<code>require: 'ngModel'</code>で、directive と同じ要素に<code>ng-model="..."</code>の記述があることを前提として実装できることになる。</p>

<p>同じ要素に<code>ng-model</code>属性の記述が無い場合、こんなエラーになる。</p>

<p><code>
Error: [$compile:ctreq] Controller 'ngModel', required by directive 'input', can't be found!
</code></p>

<p>このエラーを発生させる必要が無いなら、<code>require: '?ngModel'</code>のように<code>?</code>を付けて記述する。</p>

<h2>これでもうカスタム directive を書ける</h2>

<p>この４回目で<code>controller</code>と<code>require</code>を使って、複数の directive でコンポーネントを構成することについての理解も進んだので、どんどん directive を活用していこう！</p>
]]></content>
  </entry>
  
</feed>
