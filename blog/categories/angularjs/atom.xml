<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: AngularJS | AngularJS Ninja]]></title>
  <link href="http://angularjsninja.com/blog/categories/angularjs/atom.xml" rel="self"/>
  <link href="http://angularjsninja.com/"/>
  <updated>2013-12-08T00:19:02+09:00</updated>
  <id>http://angularjsninja.com/</id>
  <author>
    <name><![CDATA[Akihito Tamagawa]]></name>
    <email><![CDATA[tama3bb@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AngularJSでちゃちゃっとアニメーションを試す]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/07/angularjs-nganimate/"/>
    <updated>2013-12-07T23:01:54+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/07/angularjs-nganimate</id>
    <content type="html"><![CDATA[<hr />

<h2>AngularJS 1.2.4</h2>

<p>AngularJS 1.2.4 がリリースされ、$animate 関連の <a href="https://github.com/angular/angular.js/blob/master/CHANGELOG.md#1.2.4">Bug Fixes</a> が入り ng-include をネストした ng-repeat でアニメーションが効かない問題も解消されたので、アニメーションをちゃちゃっと試す方法を紹介。</p>

<h2>angular-animate.js</h2>

<p>HTML に angular と angular-animate の js ファイルを記述する。</p>

<p>``` html</p>

<p><script src="angular.min.js">
<script src="angular-animate.min.js">
```</p>

<h2>ngAnimate モジュール</h2>

<p>依存モジュールとして <code>ngAnimate</code> を記述する。</p>

<p><code>javascript
angular.module('app', [ 'ngAnimate' ])
</code></p>

<h2>CSS 定義</h2>

<p>これだけでもうゴール間近で、あとはどんなアニメーションを適用するのかを考えて定義するだけ。</p>

<p>アニメーションを CSS で定義する方法と JavaScript で記述する方法があり、ここではちゃちゃっと試すのが簡単な CSS を例示する。</p>

<p><!-- more --></p>

<p><code>css
.ng-enter,
.ng-leave,
.ng-move {
  -webkit-transition: opacity 0.15s linear;
  transition: opacity 0.15s linear;
}
.ng-enter {
  opacity: 0;
}
.ng-enter.ng-enter-active {
  opacity: 1;
}
.ng-leave {
  opacity: 1;
}
.ng-leave.ng-leave-active {
  opacity: 0;
}
.ng-move {
  opacity: .5;
}
.ng-move.ng-move-active {
  opacity: 1;
}
</code></p>

<p>この CSS 定義だけで、<code>enter</code> <code>leave</code> <code>move</code>系の<code>ngRepeat</code> <code>ngView</code> <code>ngInclude</code> <code>ngSwitch</code> <code>ngIf</code> directives に fade（フェード）のアニメーションが適用される。</p>

<h2>アニメーションを限定的に適用</h2>

<p>ちゃちゃっとアニメーションを試してみるのにはさっきの CSS で OK だけど、アニメーションされすぎで気持ち悪いとか、アニメーションのせいでむしろ遅い UI に感じられるとか、テーブルタグなどで不自然なレンダリングになるとか…。</p>

<p>なので、ちゃんとアニメーションを使うときには CSS のセレクタに class name（以下では animated）を追加し、適用箇所を限定する。</p>

<p><code>css
.animated.ng-enter,
.animated.ng-leave,
.animated.ng-move {
  -webkit-transition: opacity 0.15s linear;
  transition: opacity 0.15s linear;
}
.animated.ng-enter {
  opacity: 0;
}
.animated.ng-enter.ng-enter-active {
  opacity: 1;
}
.animated.ng-leave {
  opacity: 1;
}
.animated.ng-leave.ng-leave-active {
  opacity: 0;
}
.animated.ng-move {
  opacity: .5;
}
.animated.ng-move.ng-move-active {
  opacity: 1;
}
</code></p>

<p>そして、HTML 側でアニメーションさせたい<code>ng-if</code>や<code>ng-repeat</code>を指定した要素の class 属性に <code>animated</code> を追記する。</p>

<p><code>html
&lt;div ng-if="model.visible" class="animated"&gt;...&lt;/div&gt;
</code></p>

<p>むやみやたらにアニメーションするのでなく、こうしてポイントポイントで上品に適用していくことを心掛けよう。</p>

<h2>サンプル</h2>

<p>
<a class="jsbin-embed" href="http://jsbin.com/EpiHEwuK/26/embed?output">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>
</p>

<h2>class 属性の変化</h2>

<p>class 属性が変化する流れを見ておく。</p>

<p><code>model.visible = false;</code>（非表示状態）のときがこのようなコードだとして、</p>

<p><code>html
&lt;div ng-if="model.visible" class="animated"&gt;...&lt;/div&gt;
</code></p>

<p><code>model.visible = true;</code>（表示に切替）になるとまず<code>ng-enter</code>が追加（<code>opacity: 0;</code>）されて、</p>

<p><code>html
&lt;div ng-if="model.visible" class="animated ng-enter"&gt;...&lt;/div&gt;
</code></p>

<p>その後すぐに<code>ng-enter-active</code>が追加（<code>opacity: 1;</code>）されることでアニメーションが開始する。CSS で定義している <code>transition: opacity 0.15s linear;</code>により 0.15s の速度でフェードしながら表示（fadeIn）され、</p>

<p><code>html
&lt;div ng-if="model.visible" class="animated ng-enter ng-enter-active"&gt;...&lt;/div&gt;
</code></p>

<p>要素の class 属性は元に戻る。</p>

<p><code>html
&lt;div ng-if="model.visible" class="animated"&gt;...&lt;/div&gt;
</code></p>

<p>その逆で表示から非表示になるときには、<code>ng-enter</code>の代わりに<code>ng-leave</code>と<code>ng-leave-active</code>が class 属性に追加される。</p>

<h2>アニメーションに対応する標準 directive</h2>

<p>以下の AngularJS 標準 directive には、アニメーションのための処理が実装されているので、表示・非表示が切り替わるタイミングで class 属性に先述したような値（<code>ng-enter</code>など）が反映される。</p>

<table>
<thead>
<tr>
<th>Directive </th>
<th> Supported Animations</th>
</tr>
</thead>
<tbody>
<tr>
<td>ngRepeat </td>
<td> enter, leave, move</td>
</tr>
<tr>
<td>ngView </td>
<td> enter, leave</td>
</tr>
<tr>
<td>ngInclude </td>
<td> enter, leave</td>
</tr>
<tr>
<td>ngSwitch </td>
<td> enter, leave</td>
</tr>
<tr>
<td>ngIf </td>
<td> enter, leave</td>
</tr>
<tr>
<td>ngClass </td>
<td> add, remove</td>
</tr>
<tr>
<td>ngShow / ngHide </td>
<td> add, remove (ng-hide class 値)</td>
</tr>
</tbody>
</table>


<p>もちろんカスタム directive でも $animate service を利用して標準 directive と同じようにアニメーションを実現できるけど、その方法についてはまた別の機会に。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectでもArrayでも回せるangular.forEach]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/06/angular-foreach/"/>
    <updated>2013-12-06T13:55:45+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/06/angular-foreach</id>
    <content type="html"><![CDATA[<hr />

<h2>angular.forEach</h2>

<p>AngularJS 標準の <a href="http://docs.angularjs.org/api/ng#function">Global API</a> から、<a href="http://docs.angularjs.org/api/angular.forEach">angular.forEach</a> の紹介。</p>

<p>angular.forEach は、Object でも Array でも回してくれる。</p>

<h2>angular.forEach(Object, Function)</h2>

<p><code>javascript
var user = { name: 'ninja', gender: 'unknown', weapons: [ ..., ... ] };
angular.forEach(user, function(value, key) {
  // ...
});
</code></p>

<p>オブジェクトを回す場合の Iterator function の引数は value, key の順。</p>

<h2>angular.forEach(Array, Function)</h2>

<p><code>javascript
var records = [ { ... }, { ... } ];
angular.forEach(records, function(record, i) {
  // ...
});
</code></p>

<p>配列を回す場合の Iterator function は第１引数が配列の中身で、第２引数が配列インデックスとなる。</p>

<!-- more -->


<h2>context の指定</h2>

<p>第３引数に Iteration function での context (this) を指定できる。</p>

<p>以下、公式サイトの <a href="http://docs.angularjs.org/api/angular.forEach">angular.forEach</a> ページに掲載されているコード。</p>

<p><code>javascript
var values = {name: 'misko', gender: 'male'};
var log = [];
angular.forEach(values, function(value, key) {
  this.push(key + ': ' + value);
}, log);
</code></p>

<p>この例だと、第３引数（context）に<code>log</code>を渡していて、この<code>log</code>が iterator の中での context <code>this</code>となる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJSのminify対策がngminでラクになる]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/03/angularjs-ngmin/"/>
    <updated>2013-12-03T11:15:48+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/03/angularjs-ngmin</id>
    <content type="html"><![CDATA[<hr />

<h2>AngularJS の minify 対策、めんどくさい</h2>

<p>AngularJS の JavaScript コードを minify するには、function の引数でインジェクト（DI）する各 services の名前を、文字列として重複させて記述する必要がある。</p>

<p>これって、めっちゃめんどくさい。あほらしすぎる。</p>

<h2>ngmin</h2>

<p>そこで <a href="https://github.com/btford/ngmin">ngmin</a> を使う。</p>

<p><code>
npm install -g ngmin
</code>
<code>
ngmin somefile.js somefile.annotate.js
</code></p>

<p>以下のコードが、</p>

<p>``` javascript somefile.js
angular.module(&lsquo;app&rsquo;, [])</p>

<p>  .controller(&lsquo;TodoCtrl&rsquo;, function($scope, $timeout, Projects) {</p>

<pre><code>// comments
$scope.createTask = function(task) {
  task.title = "New Task";
};
</code></pre>

<p>  });
```</p>

<p>ngmin 後は、こうなる。</p>

<p>``` javascript somefile.annotate.js
angular.module(&lsquo;app&rsquo;, []).controller(&lsquo;TodoCtrl&rsquo;, [
  &lsquo;$scope&rsquo;,
  &lsquo;$timeout&rsquo;,
  &lsquo;Projects&rsquo;,
  function ($scope, $timeout, Projects) {</p>

<pre><code>$scope.createTask = function (task) {
  task.title = 'New Task';
};
</code></pre>

<p>  }
]);
```</p>

<!-- more -->


<p>function の引数に記述している DI する services の名前が、自動的に文字列としても列挙されるので、これで minify 対策がラクになる！</p>

<p>その他、空行・コメント行削除、シングルクオート置換も実施される。</p>

<p><a href="https://github.com/btford/ngmin">ngmin</a> は <a href="http://gruntjs.com/">Grunt</a> タスク（<a href="https://github.com/btford/grunt-ngmin">grunt-ngmin</a>）としても利用可能で自動化できる！</p>

<p><blockquote><p>Life is too short to declare the names of dependencies!</p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Directive なんてこわくない（その４）]]></title>
    <link href="http://angularjsninja.com/blog/2013/11/29/angularjs-custom-directives/"/>
    <updated>2013-11-29T15:33:32+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/11/29/angularjs-custom-directives</id>
    <content type="html"><![CDATA[<hr />

<h2>controller, require</h2>

<p><a href="/blog/2013/11/20/angularjs-custom-directives/">その１</a>、<a href="/blog/2013/11/22/angularjs-custom-directives/">その２</a>、<a href="/blog/2013/11/27/angularjs-custom-directives/">その３</a>に引き続き、今回もカスタム directive について。</p>

<p>今回のサンプルコードは、UI Bootstrap の <a href="https://github.com/angular-ui/bootstrap/tree/master/src/tabs">Tabs</a> からの一部抜粋で、<code>controller</code> <code>require</code>オプションについて見ていく。</p>

<p>``` javascript tabs.js
angular.module(&lsquo;ui.bootstrap.tabs&rsquo;, [])
.controller(&lsquo;TabsetController&rsquo;, [&lsquo;$scope&rsquo;, function TabsetCtrl($scope) {
  var ctrl = this,</p>

<pre><code>  tabs = ctrl.tabs = $scope.tabs = [];
</code></pre>

<p>  ctrl.select = function(tab) {</p>

<pre><code>angular.forEach(tabs, function(tab) {
  tab.active = false;
});
tab.active = true;
</code></pre>

<p>  };
  // &hellip;
}])</p>

<p>.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>restrict: 'EA',
transclude: true,
replace: true,
require: '^tabset',
scope: {},
controller: 'TabsetController',
templateUrl: 'template/tabs/tabset.html',
compile: function(elm, attrs, transclude) {
  return function(scope, element, attrs, tabsetCtrl) {
    // ...
  };
}
</code></pre>

<p>  };
})</p>

<p>.directive(&lsquo;tab&rsquo;, [&lsquo;$parse&rsquo;, function($parse) {
  return {</p>

<pre><code>require: '^tabset',
restrict: 'EA',
replace: true,
templateUrl: 'template/tabs/tab.html',
transclude: true,
scope: {
  heading: '@',
  onSelect: '&amp;select',
  onDeselect: '&amp;deselect'
},
controller: function() {},
compile: function(elm, attrs, transclude) {
  return function postLink(scope, elm, attrs, tabsetCtrl) {
    // ...
    scope.$watch('active', function(active) {
      setActive(scope.$parent, active);
      if (active) {
        tabsetCtrl.select(scope);
        scope.onSelect();
      } else {
        scope.onDeselect();
      }
    });
    // ...
    scope.select = function() {
      if (!scope.disabled ) {
        scope.active = true;
      }
    };
    tabsetCtrl.addTab(scope);
    scope.$on('$destroy', function() {
      tabsetCtrl.removeTab(scope);
    });
    // ...
  };
}
</code></pre>

<p>  };
}])
```</p>

<!-- more -->


<h2>controller</h2>

<p>directive にも<code>ng-controller</code>で利用するときに定義するのと同じような<code>controller</code>を記述でき、<code>$scope</code>や<code>$http</code>などをインジェクト（DI）することもできる。directive の場合でも、<code>controller</code>では DOM 操作するコードは記述しないようにし、<code>compile</code>または <code>link</code>のほうに記述する。</p>

<p>なお、directive の<code>controller</code>には、モジュールで定義した<code>controller</code>の名前を記述することができる。</p>

<p>``` javascript
.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>...,
controller: 'TabsetController',
...
</code></pre>

<p>  };
})
```</p>

<p>注意すべき点としては、再利用されるコンポーネントとして directive を作成する場合、<code>controller</code>に付ける名前が重複されにくい名前にしておくこと。</p>

<p><code>controller</code>に名前を付けずに、直接 function を記述することもできる。</p>

<p>``` javascript
.directive(&lsquo;tabset&rsquo;, function() {
  return {</p>

<pre><code>...,
controller: ['$scope', function($scope) {
  // ...
}],
...
</code></pre>

<p>  };
})
```</p>

<p><code>$scope</code>だけでなく<code>$http</code>や<code>$timeout</code>などをインジェクト（DI）できる。また、directive の<code>controller</code>では<code>$element</code> <code>$attrs</code> <code>$transclude</code>の service をインジェクトできるようになっている。</p>

<p><code>link</code>でも<code>controller</code>でも、どちらでも同じような処理を記述することができそうに思う。違う点は、DI を利用できるか否かと、処理のタイミング（<code>controller</code>が先で、<code>link</code>が後）。使い分けのヒントとしては、子要素など別の directive から呼び出すのであれば<code>controller</code>として API を公開する感じで実装し、そうでなければ<code>link</code>で実装するという感じで。</p>

<h2>require</h2>

<p>ネストされた directive から親の directive の<code>controller</code>で定義された API を呼び出すには<code>require</code>が必要となる。</p>

<p>上のコード例では、<code>require: '^tabset'</code>の記述があり、これによって<code>tabset</code> directive の<code>controller</code>である<code>tabsetCtrl</code>を参照して API を利用できるようになる。</p>

<p>``` javascript
compile: function(elm, attrs, transclude) {
  return function postLink(scope, elm, attrs, tabsetCtrl) {</p>

<pre><code>tabsetCtrl.select(scope);
tabsetCtrl.addTab(scope);
tabsetCtrl.removeTab(scope);
</code></pre>

<p>  };
}
```</p>

<p>なお、<code>^</code>を付けない場合、親階層ではなく directive を指定した要素の<code>controller</code>を探すこととなる。このケースでよく使うのは<code>require: 'ngModel'</code>で、directive と同じ要素に<code>ng-model="..."</code>の記述があることを前提として実装できることになる。</p>

<p>同じ要素に<code>ng-model</code>属性の記述が無い場合、こんなエラーになる。</p>

<p><code>
Error: [$compile:ctreq] Controller 'ngModel', required by directive 'input', can't be found!
</code></p>

<p>このエラーを発生させる必要が無いなら、<code>require: '?ngModel'</code>のように<code>?</code>を付けて記述する。</p>

<h2>これでもうカスタム directive を書ける</h2>

<p>この４回目で<code>controller</code>と<code>require</code>を使って、複数の directive でコンポーネントを構成することについての理解も進んだので、どんどん directive を活用していこう！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Directive なんてこわくない（その３）]]></title>
    <link href="http://angularjsninja.com/blog/2013/11/27/angularjs-custom-directives/"/>
    <updated>2013-11-27T12:02:43+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/11/27/angularjs-custom-directives</id>
    <content type="html"><![CDATA[<hr />

<h2>replace, transclude, scope</h2>

<p><a href="/blog/2013/11/20/angularjs-custom-directives/">前々回</a>、<a href="/blog/2013/11/22/angularjs-custom-directives/">前回</a>に引き続き、今回もカスタム directive について。</p>

<p>今回のサンプルコードは、UI Bootstrap の <a href="https://github.com/angular-ui/bootstrap/tree/master/src/alert">Alert</a> からで、<code>replace</code> <code>transclude</code> <code>scope</code>オプションについて見ていく。</p>

<p>``` javascript alert.js
angular.module(&ldquo;ui.bootstrap.alert&rdquo;, []).directive(&lsquo;alert&rsquo;, function() {
  return {</p>

<pre><code>restrict:'EA',
templateUrl:'template/alert/alert.html',
transclude:true,
replace:true,
scope: {
  type: '=',
  close: '&amp;'
},
link: function(scope, iElement, iAttrs) {
  scope.closeable = "close" in iAttrs;
}
</code></pre>

<p>  };
});
<code>
</code> html template/alert/alert.html</p>

<div class="alert" ng-class="type && 'alert-' + type">
    <button ng-show="closeable" type="button" class="close" ng-click="close()">&times;</button>
    <div ng-transclude></div>
</div>


<p><code>

</code> html
<alert ng-repeat="alert in alerts" type="alert.type" close="closeAlert($index)">
  {{alert.msg}}
</alert>
```
</p>

<!-- more -->


<h2>replace</h2>

<p><code>template</code>または<code>templateUrl</code>で指定された HTML のフラグメントは、デフォルトでは directive を指定した要素の内側に append される。</p>

<p>``` html
<alert ...>
  <div class='alert' ...></p>

<pre><code>...
</code></pre>

<p>  </div>
</alert>
```</p>

<p>このコード例のように、directive を要素として指定できるよう<code>restrict</code>に<code>'E'</code>を含めるときには、HTML として不適当な要素名が記述されることになるため、<code>replace: true</code>を指定する前提で directive を設計しよう。</p>

<p><code>replace: true</code> を指定することによって、directive を指定した要素自体を置き換えることができるので、directive がコンパイルされた結果は以下のようなコードとなる。</p>

<p>
``` html</p>

<div ng-class="type && 'alert-' + type" class="alert ng-scope" close="closeAlert($index)" type="alert.type" ng-repeat="alert in alerts">
    <button ng-click="close()" class="close" type="button" ng-show="closeable">×</button>
    <div ng-transclude=""><span class="ng-scope ng-binding">Another alert!</span></div>
</div>


<p>```
</p>

<p><code>replace: true</code> の場合、 directive を指定した要素にある属性は、テンプレート側のルート要素にコピーされる。なので、<code>ng-repeat="alert in alerts"</code>や<code>type="alert.type"</code>、<code>close="closeAlert($index)"</code>も有効となる。</p>

<p>両方に class 属性があるケースでは、両方の class 属性値をいい感じにマージしてくれる。</p>

<h2>transclude</h2>

<p><code>transclude</code>には、<code>true</code>または<code>'element'</code>を指定でき、directive とした要素の内容を、テンプレートの一部として利用できる。</p>

<p><code>javascript
transclude: true // directive 要素の内容（内側）をテンプレートで利用
transclude: 'element' // directive 要素ごとテンプレートで利用
</code></p>

<p>テンプレート側に ng-transclude を指定した要素の内側に append できる。上記サンプルコードの例では、<code>{{alert.msg}}</code>が<code>&lt;div ng-transclude&gt;</code>の内側に append される。</p>

<p>上記コード例では、<code>alert</code>directive の内側部分<code>{{alert.msg}}</code>が、<code>ng-transclude</code>に append されていることがわかる（<code>alert.msg: 'Another alert!'</code>という前提）。</p>

<h2>scope</h2>

<p>scope には、以下の３種類の指定方法がある。</p>

<p><code>javascript
scope: false // directive が利用される場所での scope を利用（デフォルト）
scope: true // directive が利用される場所での scope を継承する、新たな scope を生成
scope: {...} // directive が利用される場所での scope を継承しない、独立した新たな scope を生成
</code></p>

<p><code>scope: true</code>が指定されている代表的な directive は<code>ng-controller</code>で、ご存知のとおり<code>ng-controller</code>を利用すると scope を継承する新たな scope が生成される。これにより、親の scope にあるデータや function を利用したり、オーバーライドしたりできるようになる。</p>

<p>一方で、コンポーネントとして再利用可能な directive を設計するには、directive を利用する場所での scope による影響を受けない分離・独立した scope を生成したい。</p>

<p><code>javascript
scope: {
  name: '@', // interpolate（値、string）
  info: '=', // data bind
  cancel: '&amp;' // expression（function）
}
</code>
このように、<code>scope</code>にオブジェクトを記述することで、この directive が利用されるたびに<code>name</code> <code>info</code> <code>cancel</code>のみ存在する新たな scope が生成される。</p>

<p>なお、directive を利用する側と、テンプレート側とで異なる名前を使いたいときは、以下のように記述することができる。
<code>javascript
scope: {
  customerInfo: '=info'
}
</code>
こうすることで、テンプレート内では<code>customerInfo</code>を、directive を利用する要素での属性名には<code>info</code>を利用できるようになる。</p>

<h2>４回目へ向けて</h2>

<p>この３回目で、再利用のための directive を記述する方法が理解できた。もう Directive なんてこわくない！</p>

<p>なんだけど、<a href="/blog/2013/11/29/angularjs-custom-directives/">４回目</a>でも引き続き、<code>controller</code> <code>require</code>といった directive のプロパティを扱う。</p>
]]></content>
  </entry>
  
</feed>
