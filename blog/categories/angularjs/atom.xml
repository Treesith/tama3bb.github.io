<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: AngularJS | AngularJS Ninja]]></title>
  <link href="http://angularjsninja.com/blog/categories/angularjs/atom.xml" rel="self"/>
  <link href="http://angularjsninja.com/"/>
  <updated>2013-12-20T10:22:16+09:00</updated>
  <id>http://angularjsninja.com/</id>
  <author>
    <name><![CDATA[Akihito Tamagawa]]></name>
    <email><![CDATA[tama3bb@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AngularJSのスゴ本が今だけ安い！]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/20/mastering-web-application-development-with-angularjs/"/>
    <updated>2013-12-20T10:10:31+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/20/mastering-web-application-development-with-angularjs</id>
    <content type="html"><![CDATA[<hr />

<p><img src="https://www.packtpub.com/sites/default/files/782x300_Main_banner.jpg" alt="eBook Bonanza" /></p>

<h2>Mastering Web Application Development with AngularJS</h2>

<p>『<a href="http://www.packtpub.com/angularjs-web-application-development/book">Mastering Web Application Development with AngularJS | Packt Publishing</a>』が、Packt Publishing のサイトで年明け 1 月 3 日までたったの <strong>$ 5.00</strong> で販売中！</p>

<p>ちなみに Amazon では ￥ 1,854（2013/12/20 現在）で販売中。</p>

<p>『Mastering Web Application Development with AngularJS』は洋書だけど、AngularJS やるならこれだけは読んどけっていう、ほんとによく書かれてる本。めっちゃ勉強になってます。</p>

<p>これまでに読んだ AngularJS の本として比較できるのは O’Reilly の『AngularJS』と、Manning の『AngularJS in Action』（Early Access Edition で、まだ 6 章まで）だけど、『Mastering Web Application Development with AngularJS』が質・量ともに圧倒してる。</p>

<p>この本は、AngularJS のサンプルアプリケーション実装として GitHub で 2,274 スター（2013/12/20 現在）も付いている <a href="https://github.com/angular-app/angular-app">angular-app</a> の実装についてのパターンや技術を詳細に解説していて、実際に動作させることもできる CRUD アプリケーションで、AngularJS のフォルダ構成や modules の使い方、テスト、REST バックエンドとの接続、ナビゲーション、セキュリティ（authentication、authorization）などのベストプラクティスを学ぶことができる。</p>

<p>AngularJS やるぜって衆の年末年始は、コレで決まりだ！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[$watchと$watchの中間的な位置付けの$watchCollection]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/17/angularjs-watchcollection/"/>
    <updated>2013-12-17T00:01:26+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/17/angularjs-watchcollection</id>
    <content type="html"><![CDATA[<hr />

<h2>$watchCollection</h2>

<p><a href="">AngularJSのデータバインドを支える$watch</a> で見たように、$watch ではオブジェクトの参照を監視するか、またはオブジェクトの中身まですべて監視（deep watch）するかを切り替えることができる。</p>

<p>その 2 種類の $watch の中間に位置付けられる <a href="http://docs.angularjs.org/api/ng.$rootScope.Scope#methods_$watchcollection">$watchCollection</a> というのもあり、1 階層分だけを監視（shallow watch）してくれる。</p>

<h2>配列の場合</h2>

<p>配列の場合に $watch、$watchCollection、および $watch (deep watch) がそれぞれどのように異なるのかを見ていく。</p>

<!-- more -->


<h3>$watch</h3>

<p><code>javascript
$scope.results = [ {...}, {...}, ... ];
$scope.$watch('results', function() {...});
</code></p>

<p>$watch の場合、参照が変更されたときだけリスナーが動作する。</p>

<p><code>javascript
results[0].title = '';  // 動かない
</code></p>

<p><code>javascript
results.push({...});  // 動かない
</code></p>

<p><code>javascript
results = [...];  // 動く
</code></p>

<h3>$watchCollection</h3>

<p><code>javascript
$scope.results = [ {...}, {...}, ... ];
$scope.$watchCollection('results', function() {...});
</code></p>

<p>$watchCollection の場合、監視している配列に追加、削除などをした場合にも動作する。</p>

<p><code>javascript
results[0].title = '';  // 動かない
</code></p>

<p><code>javascript
results.push({...});  // 動く
</code></p>

<p><code>javascript
results = [...];  // 動く
</code></p>

<h3>$watch（deep watch）</h3>

<p><code>javascript
$scope.results = [ {...}, {...}, ... ];
$scope.$watch('results', function() {...}, true);
</code></p>

<p>$watch (deep watch) の場合、なにかしらあれば動作する。</p>

<p><code>javascript
results[0].title = '';  // 動く
</code></p>

<p><code>javascript
results.push({...});  // 動く
</code></p>

<p><code>javascript
results = [...];  // 動く
</code></p>

<h2>普通のオブジェクトの場合</h2>

<p><code>javascript
$scope.user = {
  name: 'unknown',
  images: [...]
};
$scope.$watchCollection('user', function() {...});
</code></p>

<p>普通のオブジェクトを対象とした $watchCollection の動作は、監視しているオブジェクトのプロパティ値の変更や、プロパティの追加・削除でも動作する。</p>

<p><code>javascript
user.images.push(...);  // 動かない
</code></p>

<p><code>javascript
user.name = 'known';  // 動く
</code></p>

<p><code>javascript
user.newProperty = 'new prop!';  // 動く
</code></p>

<p><code>javascript
user = {...};  // 動く
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS 1.3 では IE 8 がサポートされない]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/15/angularjs-1.3-discontinues-support-for-ie8/"/>
    <updated>2013-12-15T16:16:01+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/15/angularjs-1.3-discontinues-support-for-ie8</id>
    <content type="html"><![CDATA[<hr />

<p>AngularJS 1.3 についての記事『<a href="http://blog.angularjs.org/2013/12/angularjs-13-new-release-approaches.html">AngularJS 1.3: a new release approaches</a>』が公式ブログのほうに上がりました。</p>

<p>日本でのエンタープライズ（業務系）なんかでは、まだまだ IE 8 は当たり前のようにサポート対象のブラウザになっているところが多いと思うので、ちょっと大きなニュースですね。</p>

<p>なお、AngularJS 1.2.x 以前を IE 8 で動作させるには、過去記事『<a href="/blog/2013/09/11/angularjs-ie-compatibility/">AngularJS を古い IE に対応させるには</a>』をご参照ください。</p>

<h2>AngularJS 1.3 は IE 8 をサポートしない</h2>

<p>サポートをやめる理由としては、IE 8 で動作させるためのコードのせいで性能に悪影響があるし、すでに IE 8 ユーザは全体の数パーセント程度だし、Microsoft による Windows XP のサポートも 2014年4月に終わるし、とのこと。動作性能の向上はもちろん、機能を追加していくのも速くなると。</p>

<p>どうしても IE 8 で動作させ続けたい場合は：</p>

<ul>
<li>AngularJS 1.2.x を使い続ける</li>
<li>AngularJS 1.3 をトライする</li>
<li>IE 8 で動作する AngularJS を商用サポートとして提供する会社を見つける。</li>
</ul>


<p>1.3 バージョンでは IE 8 用のハックを積極的に削除していくことはないようで、1.2.x バージョンのアプリケーションが IE 8 で動作しているのであれば、大部分は 1.3 でも動作するのではないかということ。ただし、1.3 では IE 8 向けのテストもバグフィックスも実施しなくなると。</p>

<!-- more -->


<h2>非推奨（deprecated）の API を削除</h2>

<p><a href="https://github.com/angular/angular.js/commit/5dc35b527b3c99f6544b8cb52e93c6510d3ac577">fix($parse): deprecate promise unwrapping and make it an opt-in</a></p>

<p>promise の unwrapping についてのことを指しているようで、この API のことは以前の記事『<a href="/blog/2013/10/26/angularjs-1.2.0-rc3-promises/">AngularJS 1.2.0-rc3 以降の Promise</a>』をご参照ください。</p>

<h2>リリースバージョンの命名規約</h2>

<p>odd/even versioning から、semantic versioning に切り替えるということで、以前は 1.1.x（奇数）を開発バージョン、1.0.x や 1.2.x（偶数）を安定バージョンとしてきたバージョニングを、1.3.0-beta.1、1.3.0-beta.2 などを経て、安定版 1.3.0 リリースとするバージョニングになるということ。</p>

<h2>1.3 新機能についてコメントを！</h2>

<p>1月2日まで 1.3 での<a href="https://github.com/angular/angular.js/issues?milestone=32&amp;page=1&amp;state=open">新機能</a>についてのコメントを受け付けているようです。"+1" とコメントすれば投票したことに。</p>

<h2>1.3（ベータ）リリースはいつ頃か</h2>

<p>1.3 の最初のベータバージョンが 1 月で、その後 1 〜 2 週間間隔でリリース。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS のデータバインドを支える $watch]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/13/angularjs-watch/"/>
    <updated>2013-12-13T18:43:39+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/13/angularjs-watch</id>
    <content type="html"><![CDATA[<hr />

<h2>$watch</h2>

<p>AngularJS の強力なデータバインドを支える仕組みのうち、まず <a href="http://docs.angularjs.org/api/ng.$rootScope.Scope#methods_$watch">$watch</a> について取り上げる。</p>

<p>$watch を使えば、監視（Observe）したいオブジェクトやプロパティが変化したときに実行する処理（リスナー）を容易に記述できる。</p>

<p>$watch を利用する場所は scope のある directive や controller で、ng-model や ng-bind のようなデータバインドする directive を独自に実装する場合や、モデルの変更に応じて処理をバインドする場合などに使用できる。</p>

<h2>$digest サイクル</h2>

<p>$watch による変更検知処理は、ポーリング的（一定間隔で頻繁）に実施されるのではなく、以下のイベントが生じたときに $digest サイクル（または $digest ループ）と呼ばれる処理が実行され、その中で実行される。</p>

<table>
<thead>
<tr>
<th>イベント </th>
<th> 概要</th>
</tr>
</thead>
<tbody>
<tr>
<td>ナビゲーション </td>
<td> ブラウザの location 変更時</td>
</tr>
<tr>
<td>ネットワーク </td>
<td> $http, $resource レスポンス受信時</td>
</tr>
<tr>
<td>DOM イベント </td>
<td> ng-click, ng-mouseover などの実行時</td>
</tr>
<tr>
<td>タイマー </td>
<td> $timeout によるタイマー処理の実行時</td>
</tr>
</tbody>
</table>


<!-- more -->


<h2>構文</h2>

<p><code>$watch(watchExpression, listener, objectEquality)</code></p>

<h3>watchExpression</h3>

<p>監視したいオブジェクトや値（を返す function）を第 1 引数に指定する。</p>

<p><code>javascript
$scope.$watch(function() {
  return $location.path();
}, function() {
  // $location の path が変わった時
});
</code></p>

<p>scope にあるオブジェクトや値であれば、文字列で指定できる。</p>

<p><code>javascript
$scope.name = 'unknown';
$scope.$watch('name', function() {
  // scope の name が変わった時
});
</code></p>

<h3>listener</h3>

<p>watchExpression で監視しているオブジェクトや値が変化したときに実行するリスナー function を第 2 引数に指定する。</p>

<p>変更後の値だけでなく、変更前の値を参照することもできる。</p>

<p><code>javascript
$scope.name = 'unknown';
$scope.$watch('name', function(newVal, oldVal) {
  // newVal: 変更後の値: 'Hanzo'
  // oldVal: 変更前の値: 'unknown'
});
$scope.name = 'Hanzo';
</code></p>

<p>なお、このリスナー function についても、scope に定義があれば文字列で指定できる。</p>

<h3>objectEquality</h3>

<p>ここまでのコード例では、すべて $watch の対象となる watchExpression が文字列であったため、変更が常に検知される。</p>

<p>watchExpression がオブジェクトの場合には注意が必要で、この第 3 引数を省略（または false を指定）している場合は reference（同じオブジェクトを参照しているか）で比較されることとなり、オブジェクトのプロパティ値が変わろうと配列の中身が変わろうと、変化したとは扱われない。</p>

<p>このオブジェクト id での比較のほうが高速に処理されるが、どうしてもオブジェクトをプロパティごとに比較したい場合には、第 3 引数 objectEquality に true を指定する。性能の点では不利になるが、オブジェクトや配列の中身が変更されたかを検知できるようになる。</p>

<p>なお、性能だけでなく、新旧比較のためにオブジェクトや配列全体のコピー（angular.copy）を保持することになり、メモリ消費の点でも不利になる。</p>

<p><code>javascript
$scope.user = {
  name: 'unknown',
  gender: 'male'
  …
};
$scope.$watch('user', function(newVal, oldVal) {
  // newVal: user オブジェクト
  // オブジェクトの参照が変わった時、または オブジェクトのいずれかのプロパティが変わった時
  if (newVal) {  // オブジェクトの場合は undefined チェックを
  }
}, true);  // 性能、メモリ消費の点からできるだけ true を指定しない方法を検討すべき
</code></p>

<p>単にオブジェクトが持つ特定のプロパティを監視したいだけであれば、以下のように記述しよう。</p>

<p><code>javascript
$scope.$watch('user.name', function(newVal, oldVal) {
  // newVal: user オブジェクト
  // オブジェクトの name プロパティが変わった時
});
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJSのHTMLバインド  ではundefinedを気にしない]]></title>
    <link href="http://angularjsninja.com/blog/2013/12/10/angularjs-expressions-forgiving/"/>
    <updated>2013-12-10T02:09:47+09:00</updated>
    <id>http://angularjsninja.com/blog/2013/12/10/angularjs-expressions-forgiving</id>
    <content type="html"><![CDATA[<hr />

<h2>Forgiving</h2>

<p><a href="http://docs.angularjs.org/guide/expression">AngularJS: Expressions</a> ページで <a href="http://docs.angularjs.org/guide/expression#property-evaluation_forgiving">Forgiving</a> として説明されているように、HTML（テンプレート）で記述する AngularJS のバインド部分（<code>{{ result.title.value }}</code> や<code>ng-if=“result.tags.length”</code>）では、result、title、tags が、undefined や null でないかや object かどうかということを考慮したコードにしなくていい。</p>

<p>result が通信してサーバから取得するデータであれば、レスポンスが返るまでの間 result は undefined の状態になるけど、だからと言って<code>{{ ((result || {}).title || {}).c }}</code>とか、<code>result &amp;&amp; result.title &amp;&amp; result.title.value</code>のようにコーディングしなくていい。</p>

<!-- more -->


<h2>サンプル</h2>

<p>以下のサンプルでは、<code>ng-hide="result.hidden"</code>のとこで、result なんて定義してないので undefined だけど、エラーにならずに falsy として扱われている。</p>

<p><a class="jsbin-embed" href="http://jsbin.com/oTOMaFIJ/11/embed?html,output">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script></p>
]]></content>
  </entry>
  
</feed>
